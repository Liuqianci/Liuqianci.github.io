---
title: 补码
date: 2025-03-31 16:15:36
tags:
    - C++基础
categories:
    - C++
mathjax: true
---

# 机器数和真值

机器数：一个数在计算机中的二进制表示形式，叫做这个数的机器数。

机器数是带符号的，在计算机中用一个数的最高位存放符号，正数为0，负数为1；

比如：十进制数+3，就是00000000000000000000000000000011；十进制数-3，就是10000000000000000000000000000011；（int值占4字节）；这个例子只是整型数，浮点数有其他表达方式。

&emsp;

真值：真正的数学意义上的数值。因为机器数第一位是符号位，所以机器数的形式就不等于真正的数值。

&emsp;

# 补码

按照上面的机器数的表示方法有一个问题，第一位用作符号位的话，这个数的表示范围会变小。所以计算机中存储用的并不是机器数，而是补码。

&emsp;

## 无符号数的编码

用一个函数$B2Y_w$（Binary to Unsigned的缩写，长度为w）来表示：$B2Y_w(\overrightarrow{x}) = \sum_{i=0}^{w-1}x_i2^i$

eg:

$B2Y_4([0001]) = 0 \times 2^3 + 0 \times2^2 + 0 \times 2^1 + 1 \times 2^0 = 0+0+0+1 = 1$

$B2Y_4([0101]) = 0 \times 2^3 + 1 \times2^2 + 0 \times 2^1 + 1 \times 2^0 = 0+4+0+1 = 5$

$B2Y_4([1011]) = 1 \times 2^3 + 0 \times2^2 + 1 \times 2^1 + 1 \times 2^0 = 8+0+2+1 = 11$

$B2Y_4([1111]) = 1 \times 2^3 + 1 \times2^2 + 1 \times 2^1 + 1 \times 2^0 = 8+4+2+1 = 15$

&emsp;

## 有符号数的补码

用一个函数$B2T_w$（Binary to Two`s-complement的缩写，长度为w）来表示：$B2T_w(\overrightarrow{x}) = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_i2^i$

eg:

$B2T_4([0001]) = -0 \times 2^3 + 0 \times2^2 + 0 \times 2^1 + 1 \times 2^0 = 0+0+0+1 = 1$

$B2T_4([0101]) = -0 \times 2^3 + 1 \times2^2 + 0 \times 2^1 + 1 \times 2^0 = 0+4+0+1 = 5$

$B2T_4([1011]) = -1 \times 2^3 + 0 \times2^2 + 1 \times 2^1 + 1 \times 2^0 = -8+0+2+1 = -5$

$B2T_4([1111]) = -1 \times 2^3 + 1 \times2^2 + 1 \times 2^1 + 1 \times 2^0 = -8+4+2+1 = -1$

&emsp;

# 补码数值范围

|数|8位字长|16位字长|32位字长|64位字长|
|:--|:--|:--|:--|:--|
|UMax|0xFF<br>255|0xFFFF<br>65535|0xFFFFFFFF<br>4294967295|0xFFFFFFFFFFFFFFFF<br>18446744073709551615|
|TMin|0x80<br>-128|0x8000<br>-32768|0x80000000<br>-2147483648|0x8000000000000000<br>-9223372036854775808|
|TMax|0x7F<br>127|0x7FFF<br>32767|0x7FFFFFFF<br>2147483647|0x7FFFFFFFFFFFFFFF<br>9223372036854775807|
|-1<br>0|0xFF<br>0x00|0xFFFF<br>0x0000|0xFFFFFFFF<br>0X00000000|0xFFFFFFFFFFFFFFFF<br>0X0000000000000000|

需要注意，无符号数中0xFFFFFFFF是最大值，但有符号数中这个值代表-1；还要注意有符号数中的最小值是0x80000000;

&emsp;

# 字节序（Byte Ordering）

以32位机器为例，一个字有32bits字长，占用4bytes，在内存中有以下两个存放方式：

1. 大端法（Big Endian）:大多数IBM机器、Internet传输；

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/BigEndian.png)

2. 小端法（Little Endian）:Inter兼容机

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/SmallEndian.png)


个人机器基本上都是小端表示法。

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E8%B0%83%E8%AF%95.png)

# 补码的意义

&emsp;&emsp;我们在设计软件系统时总是希望软件系统尽可能的简单通用。于是人们希望在只有加法运算器的情况下设计一种方法能实现减法运算。

&emsp;&emsp;以时间为例：表盘一圈12个小时，现在是8点，那么3小时前是5点，9小时以后还是5点(8+9-12)，这里进行的是模12的操作。所以8-3和8+9的结果是一样的；我们就可以用9来表示-3，如果想计算8-3，那么就用加法器计算8+9；

&emsp;&emsp;当然单纯的这么想是有问题的，以时间为例我们可以得到一个对照表，遇见12就清零：

|0|-1|-2|-3|-4|-5|-6|-7|-8|-9|-10|-11|
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|
|0|11|10|9|8|7|6|5|4|3|2|1|

+ 5-3 ==> (5+9)%12=2
+ 3-5 ==> (3+7)%12 = 10 ==>-2

&emsp;&emsp;我们计算3-5的时候，得到的值是10，我们可以在对照表中得到10对应的值是-2，但我们计算5-3的时候，得到的值是2，我们却不需要找对应的值。计算机如何区分什么时候要找对应的值，什么时候不需要呢？

&emsp;&emsp;可以对表进行一些修改：

|0|-1|-2|-3|-4|-5|-6|5|4|3|2|1|
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|
|0|11|10|9|8|7|6|5|4|3|2|1|

+ 5-3 ==> (5+9)%12=2 ==>2
+ 3-5 ==> (3+7)%12 = 10 ==>-2

&emsp;&emsp;表格修改后，每次计算完都在表格中进行对照，这样操作统一，得到的值也是正确的了。其实在计算机内部，补码的用处就是构造这张映射表的。

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/%E8%A1%A5%E7%A0%81%E5%B1%95%E7%A4%BA.png)


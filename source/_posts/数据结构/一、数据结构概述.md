---
title: 一、数据结构概述
date: 2024-05-30 02:14:48
tags:
    - 数据结构概述
categories:
    - 考研初试
    - 数据结构
mathjax: true
top: 50
---

# 基本概念
## 数据结构的基本概念
### 数据
&emsp;&emsp;信息的载体。计算机程序加工的原料。

### 数据元素
&emsp;&emsp;数据的**基本单位**；由若干数据项组成；

### 数据对象
&emsp;&emsp;**相同性质**的数据元素的集合；

### 数据类型
&emsp;&emsp;值的集合和此集合的一组操作的总称。
以bool为例：值的集合：true和false；操作：与、或、非

- 原子类型：不可再分：如int、bool；
- 结构类型：可以再分，如struct；
- 抽象数据类型：抽象数据组织和相关操作。ADT，只考虑结构和运算，不考虑存储结构。

### 数据结构
&emsp;&emsp;相互之间存在一种或多种特定关系的数据元素的集合。数据结构只关心数据之间的关系，不关心内容。


## 数据结构的三要素
### 逻辑结构
&emsp;&emsp; 描述元素之间的逻辑关系，独立于计算机。

- 集合：没有什么关系
- 线性结构：一对一
- 树形结构：一对多
- 图状结构\网状结构：多对多

### 存储结构
&emsp;&emsp;逻辑结构的计算机实现。
&emsp;&emsp;顺序存储必须连续，非顺序存储可以离散；存储结构影响空间分配的方便程度（增删改）；存储结构影响对数据的运算（查询）；

- 顺序存储
- 链式存储
- 索引存储
- 散列存储

### 运算
&emsp;&emsp;包括定义和实现；定义针对逻辑结构，表示功能（增删改查）；实现针对存储结构



# 算法
## 算法的概念
**程序=数据+算法**

+ 数据：描述问题，存入计算机；
+ 算法：高效处理数据，是求解问题的步骤；

算法的五大特性：

1. 有穷性：算法必须有穷，程序可以无穷
2. 确定性：相同输入必须相同输出
3. 可行性
4. 输入：有零个或多个输入
5. 输出：有一个或多个输出

## 时间复杂度
评价时间开销与问题规模n之间的关系。
### 时间复杂度的计算
&emsp;&emsp;语句的频度就是该语句在算法中被重复执行的次数。算法中所有语句的频度之和就是T(n)。时间复杂度就是分析$T(n)$的数量级$O(f(n))$。O代表同阶。

计算步骤：

1. 找到一个基本操作：基本操作指的是最深层循环；
2. 分析该基本操作的执行次数x与问题规模n的关系 $x=f(n)$
3. x的数量级$O(x)$就是算法时间复杂度$T(n)$

### 常用技巧

1. 顺序执行的代码只影响常数项，可以忽略；
2. 只需要挑循环中的一个基本操作，分析它的执行次数x与n的关系；
3. 多层嵌套循环，只关注最深层循环循环了几次；

&emsp;
&emsp;


加法规则：只保留最高阶，且系数变为1。

$T(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))$

&emsp;
&emsp;

乘法规则：多项相乘，都保留

$O(f(n)) \times O(g(n)) =O(f(n) \times g(n))$


&emsp;

时间复杂度常见大小排序：**常对幂指阶**

$O(1) < O(\log_{2}n) < O(n) < O(n\log_{2}n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$


&emsp;

&emsp;

时间复杂度不仅依赖问题的规模，还与输入数据的性质有关。可以分为最好时间复杂度、平均时间复杂度、最坏时间复杂度。一般只考虑最坏时间复杂度。

&emsp;

&emsp;

```C++
//例1：
void test(int n)
{
    int i=1;            //1次
    while(i<=n){
        i++;            //循环内执行n次
        printf("test"); //循环内执行n次
    }
}

int main()
{
    test(n);
}


```
第一句顺序执行代码走1次，深层循环内执行了2n次，所以T(n)=2n+1。根据加法规则，只保留最高阶,且系数变为1.

$T(n)=O(n)$

&emsp;

&emsp;



```C++
//例2:
void test2(int n)
{
    int i=1;
    while(i<=n){
        i++;
        for(int j=1;j<=n;j++){
            printf("test2");
        }
    }
}

```

最深层循环走$n^2$次，所以$T(n)=O(n^2)$

&emsp;

&emsp;




```C
//例3
void test3(int n)
{
    while(i<=n){
        i=i*2;    //每次翻倍
    }
}
```
设最深层循环的语句频度为$x$，则每次变化后，i=$2^x$，所以由循环条件可得，循环结束时，满足$2^x>n$。所以$x= \log_2n$。

$x=O(x) = O(\log_2n)$


&emsp;


&emsp;


```C
void test(inf flag[],int n)
{
    for(int i=0;i<n;i++){  //从第一个元素开始查找
        if(flag[i] == n){
            printf("find!!");
            break;
        }
    }
}

int flag[n]={1,2,...}  //乱序存放1~n
```
因为是乱序存放。所以要考虑不同情况：
- 最好时间复杂度：元素n在第一个位置。$T(n)=O(1)$;
- 最坏时间复杂度：元素n在最后有个位置。$T(n)=O(n)$
- 平均时间复杂度：元素n在任意一个位置的概率相同，都是$\frac{1}{n}$。$T(n)=O(n)$


## 空间复杂度
评价空间开销与问题规模n之间的关系。
$S(n)=O(g(n))$

- 普通程序：
  1. 找到所占空间大小与问题规模相关的变量；
  2. 分析所占空间x与问题规模n的关系$x=g(n)$；
  3. x的数量级$O(x)$就是算法的空间复杂度S(n)；
- 递归程序：
  1. 找到递归调用的深度x与问题规模n的关系$x=g(n)$;
  2. x的数量级$O(x)$就是算法的空间复杂度S(n)；
  3. 注：考研大概率空间复杂度就是递归调用的深度。但有的算法各层函数所需存储空间不同，分析方法略有区别
- 空间复杂度也遵循加法规则、乘法规则


&emsp;

&emsp;

```C
void test(int n)
{
    int i=1;
    while(i<=n){
        i++;
    }
}
```
这个代码无论问题规模n有多大，算法所需要的运行空间都是固定的常量。算法空间复杂度是$S(n)=O(1)$。这种常数阶的空间复杂度算法称为**原地工作算法**。

&emsp;

&emsp;

```C
void test2(int n)
{
    int flag[n];
    ...
    
}
```
$S(n)=O(n)$。只关注存储空间大小与问题规模相关的变量。


&emsp;

&emsp;

```C
void test3(int n)
{
    if(n>1){
        test3(n-1);
    }
    
}
```
$S(n)=O(n)$。递归大概率和递归深度有关。每次递归，系统都要开辟一片内存空间存储参数、局部变量等等。

&emsp;

&emsp;

```C
void test4(int n)
{
    int flag[n];
    if(n > 1){
        test4(n-1);
    }
    
}
```
flag[n]的空间大小，会随着递归而发生变化。是个等差数列。$S(n)=O(n^2)$
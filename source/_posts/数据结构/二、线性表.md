---
title: 二、线性表
date: 2024-06-04 01:14:48
tags:
    - 数据结构
categories:
    - 考研初试
    - 数据结构
mathjax: true
top: 50
---

# 逻辑结构--线性表的定义

线性表是具有数据类型的n(n$\geq$ 0)个数据元素的**有限序列**。n为表长，n=0时称为空表。

+ 相同数据类型：每个元素所占空间一样大；
+ 有限：长度必须有限，比如所有整数就不是个线性表
+ 序列：必须有次序

$L=(a_1,a_2,...a_i,a_{i+1},...,a_n)$

+ $a_i$是线性表的”第i个“元素线性表中的位序；
+ $a_1$是表头元素，$a_n$是表尾元素。注意线性表的位序是从1开始，数组下标是从0开始；
+ 除表头外，每个元素都有直接前驱；除表尾外，每个元素都有直接后继；

# 运算--线性表的基本操作

基本操作是指最核心、最基本的操作。其他复杂操作都可以通过调用基本操作来实现。

所有基本操作都可以归结为创建、销毁、增删改查

+ 创建和销毁：
  + InitList(&L):初始化表。构造一个空的线性表L，分配内存空间；
  + DestoryList(&L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间；
+ 增删操作
  + ListInsert(&L, i, e):插入操作。在表L中的第i个位置插入指定元素e;
  + ListDelete(&L, i, &e):删除操作，删除表L中第i个位置的元素，并用e返回删除元素的值
+ 查询操作（改之前也需要查询）
  + LocateElem(L, e):按值查找操作。在表L中查找具有给定关键字值的元素；
  + GetElem(L, i):按位查找，获取表L中第i个位置的元素的值；
+ 其他常用操作：
  + Length(L):求表长。返回线性表L的长度，即L中数据元素的个数；
  + PrintList(L):输出操作。按照前后顺序输出线性表L的所有值；
  + Empty(L):判空操作。若L为空表，则返回true，否则返回false；


# 存储结构

## 顺序表

### 顺序表的定义

&emsp;&emsp;用顺序存储方式实现线性表的顺序存储。把**逻辑上相邻**的元素存储在**物理位置也相邻**的存储单元中，元素之间的关系用存储单元的邻接关系来体现。

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8.png)

顺序表的特点：

+ 随机访问：因为在内存中连续存储，所以在$O(1)$时间内即可找到第i个元素,代码实现data[i-1];
+ 存储密度高，每个节点只需要存储数据元素本身
+ 拓展容量不方便，即使是动态存储，拓展长度的时间复杂度也很高，因为需要复制原来的元素；
+ 插入、删除操作不方便，需要移动大量的元素；

#### 静态分配

静态分配就是用数组的方式来实现顺序表。

```C
#define MaxSize 10    //定义最大长度
typedef struct {
	ElemType data[MaxSize];  //用静态的“数组”存放数据元素
	int length;				 //顺序表的当前长度
}SqList;

```

```C
void InitList(SqList& L) {
  for (int i = 0; i < MaxSize; i++) {
    L.data[i] = 0;    //将顺序表的所有元素设置为默认值
	}
  L.length = 0;        //顺序表的初始长度为0
}

int main() {
  //声明一个顺序表，在内存中分配存储空间
  SqList L;
  
  //初始化顺序表
  InitList(L);
}
```

顺序表的局限性：顺序表的表长在刚开始确定后就无法更改。


#### 动态分配

```C
#define InitSize 10    //顺序表的初始长度

typedef struct {
  ElemType *data;     //指示动态分配数组的指针
  int MaxSize;        //顺序表的最大容量
  int length;         //顺序表的当前长度
}SeqList;

//C语言动态申请和释放内存空间--malloc、free
L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);

//C++动态申请和释放内存空间--new、delete
L.data=new ElemType[InitSize];
```

```C
#define InitSize 10    //顺序表的初始长度

typedef struct {
	int *data;     //指示动态分配数组的指针
	int MaxSize;        //顺序表的最大容量
	int length;         //顺序表的当前长度
}SeqList;

void InitList(SeqList& L) {
	L.data = (int*)malloc(InitSize * sizeof(int));
	L.length = 0;
	L.MaxSize = InitSize;
}

//增加动态数组长度
void IncreaseSize(SeqList& L, int len)
{
	int* p = L.data;    //p和L.data指向同一个地址位置
	L.data = (int*)malloc((L.MaxSize + len) * sizeof(int));   //L.data指向新的地址空间
	for (int i = 0; i < L.length; i++) {
		L.data[i] = p[i];   //将数据复制到新区域
	}
	L.MaxSize = L.MaxSize + len;   //顺序表最大长度增加len
	free(p);          //释放原来的内存空间
}

int main() {

	SeqList L; //声明顺序表
	InitList(L); //初始化顺序表

	IncreaseSize(L, 5);
}
```

动态存储不是链表，物理结构没有发生变化，都是连续的地址空间。只是可以运行时动态决定分配的内存地址空间。


### 基本操作

#### 插入

实现在线性表L中的$i$($1\leq i\leq L.length+1$)位置插入元素$e$。要注意$i$代表线性表的位序，是从1开始的，而内部使用的数组下标是从0开始的。

```C
bool ListInsert(SqList& L, int i, Elemtype e)
{
	//首先判断i的范围是否有效
	if (i<1 || i>L.length + 1)   //用i>length+1是要保证线性表内部数据必须连续，当前长度为length，最多只能在length+1处插入
		return false;
	if (L.length >= MaxSize)   //存储空间已满
		return false;

	for (int j = L.length; j >= i; j--)
	{
		L.data[j] = L.data[j - 1];    //i位置后面的元素挨个后移。注意数组下标
	}

	L.data[i - 1] = e;      //i位置插入e，注意数组下标
	L.length++;				//线性表长度++
	return true;
}
```

时间复杂度计算最深层循环，即元素后移时的次数

+ 最好时间复杂度：表尾插入，i=n+1（length+1），不需要后移，时间复杂度$O(1)$;
+ 最坏时间复杂度：表头插入，i=1,原有的n个元素都需要向后移动，时间复杂度$O(n)$；
+ 平均时间复杂度：新元素插入到任何一个位置的概率都相同，即i=1,2,3,……,length+1的概率都是p=1/(n+1)，每个$p_i$相加，等差数列求和，的n/2,所以时间复杂度$O(n)$;
---
title: 三、栈、队列、数组
date: 2024-10-01 23:21:30
tags:
    - 数据结构
categories:
    - 考研初试
    - 数据结构
mathjax: true
top: 50
---

# 栈

## 逻辑结构

栈是只允许在**一端进行**插入或删除操作的**线性表**。

几个术语：

+ 栈顶：线性表允许插入删除的那一端；
+ 栈底：固定的、不允许进行插入和删除的那一端；
+ 空栈：不含任何元素的空表； 
+ 特点：后进先出（LIFO）


![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png)



栈的常考题型：给定进栈顺序，判断有哪些合法的出栈顺序？n个不同元素进栈，出栈元素不同的排列顺序为$\frac{1}{n+1}C_{2n}^n$，称为卡特兰数。


## 存储结构

### 顺序存储

#### 顺序栈的实现

```C
#define MaxSize 10   //栈的最大个数
typedef struct{   
    ElemType data[MaxSize];   //静态数组存放栈的元素
    int top;                  //栈顶指针(数组下标)
}SqStack;

```



+ 栈顶指针：S.top，指向栈顶元素，可以理解为数组下标，初始时S.top=-1，栈顶元素表示为S.data&#91;S.top&#93;
+ 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素；
+ 出栈操作：栈非空时，先找栈顶元素值，再将栈顶指针减1；
+ 栈空条件：S.top==-1
+ 栈满条件：S.top == MaxSize-1;栈长S.top+1;


#### 基本运算代码

栈的基本运算的时间复杂度都是$O(1)$

```C
//初始化
void InitStack(SqStack &S)
{
    S.top = -1;
}

//判空
bool StackEmpty(SqStack S)
{
    if(S.top == -1)
        return true;
    else
        return false;
}

//进栈
bool Push(SqStack &S, ElemType x)
{
    if(S.top == MaxSize -1)    //栈满了
        return false;

    S.top = S.top + 1;       //指针先+1
    S.data[S.top] = x;       //新元素再入栈
    return true;
}

//出栈  
//注意，出栈操作只是逻辑上被删除出栈了，但数据依旧残留在内存中
bool Pop(SqStack &S, ElemType &x)
{
    if(S.top == -1)    //栈空
        return false;

    x = S.data[S.top];    //栈顶元素先出栈
    S.top = S.top - 1;     //指针再减1
    return true;
}

//读栈顶元素
bool GetTop(SqStack S, ElemType &x)
{
    if(S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}

```

上述设计都是栈顶指针初始化为-1，即指向当前栈顶位置，此时入栈和出栈都需要先变更指针再操作数据；如果栈顶指针初始化为0，即指向下一个操作数的位置，那么正好相反，入栈和出栈需要先操作数据，再变更指针。


顺序栈的缺点：用静态数组存放元素，栈的大小不可改变。但如果我们一开始就分配非常大的地址空间，那么又会造成资源浪费。所以我们可以利用相对栈底位置不变的特性，让两个顺序栈公用一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延申。这个就是**共享栈**


![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B1%E4%BA%AB%E6%A0%88.png)


```C
#define Max 50
typedef struct{
    ElemType data[MaxSize];
    int top0;           //0号栈顶指针
    int top1;           //1号栈顶指针
}

//初始化
void InitStack(ShStack &S){
    S.top0 = -1;
    S.top1 = MaxSize;
}

```

+ top0=-1时，0号栈为空；top1=MaxSize时，1号栈为空；
+ 栈满条件：top0 + 1 == top1
+ 0号栈进栈时，top0先加1再赋值；1号栈进栈时，top1先减1再赋值；


共享栈目的：

+ 更好的利用存储空间；
+ 两个栈互相调节，只有再整个存储空间都被占满时才发生上溢；

### 链式存储

链式存储方式完全可以类比链表操作，只是规定了只能在链表的一端（表头）进行操作。一般规定链栈没有头结点，LHead直接指向栈顶元素。

```C++
typedef struct Linknode
{
    ElemType data;            //数据域
    struct Linknode* next;    //指针域
}*LiStack;
```

## 基本操作

+ InitStack(&s) ：初始化一个空栈；
+ StackEmpty(s):判断是否为空；
+ Push(&s,x):进栈；
+ Pop(&s,&x):出栈；
+ GetTop(s,&x):读栈顶元素
+ DestroyStack(&s):销毁栈并释放存储空间

# 队列

## 逻辑结构

队列是只允许在一端进行插入，在另一端进行删除的**线性表**

+ 队头：允许删除的一端
+ 队尾：允许插入的一端
+ 特点：先进先出（FIFO）

## 存储结构

### 顺序存储结构

#### 顺序存储实现

分配一块连续的存储单元存放队列中的元素，并设置两个指针指向队头和队尾的下一个位置；

```C++
#define MAXSzie 10
typedef struct{
    ElemType data[MaxSize];   //静态数组存放队列元素
    int front,rear;           //队头指针和队尾指针
}SqQueue;

//初始化队列
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;    //初始化时，队头和队尾指针都指向0
}

```

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png)

上图指出了顺序队列的的操作：

+ 初始状态：front和rear都是0；
+ 入队操作：队列不满时，先将值送入队尾，然后队尾指针+1；
+ 出队操作：队不空时，先取头元素值，再将队头指针+1；
+ 判空条件：Q.front == Q.rear = 0;

注意，**不能使用**【Q.rear == MaxSize】来判断队列是否已满，可以看到上图虽然已经出队了，哪怕只剩最后一个元素，但此时Q.rear还是等于MaxSize，这种情况是假溢出（上溢出）。

#### 循环队列

普通的顺序队列可能存在上溢出的情况，所以可以使用循环队列，把顺序队列臆造为一个环状空间。

![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png)

+ 初始状态：Q.front = Q.rear = 0;
+ 入队操作，队尾+1取模：Q.rear = (Q.rear+1) % MaxSize
+ 出队操作，队头+1取模：Q.front = (Q.front + 1) % MaxSize
+ 获取队列长度：(rear + MaxSize - front) % MaxSize

```C++
//队列判空
bool QueueEmpty(SqQueue Q){
    if(Q.rear == Q.front){
        return true;
    }
    else{
        return false;
    }
}

//入队操作
bool EnQueue(SqQueue &Q, ElemType x){
    if((Q.rear + 1) % MaxSize == Q.front)   //判断队满的条件:队尾指针的下一个位置就是队头
        return false;
    Q.data[Q.rear] = x;   //新元素插入队尾
    Q.rear = (Q.rear+1) % MaxSize;    //队尾元素+1后取模，这样可以实现循环
    return true;
}

//出队操作
bool DeQueue(SqQueue &Q, ElemType &x){
    if(Q.rear == Q.front){   //队列为空
        return false;
    }

    x = Q.data[Q.front];   //取队头
    Q.front = (Q.front + 1) % MaxSize;   //队头指针后移
    return true;
}

//获取队头
bool GetHead(SqQueue Q, ElemType &x){
    if(Q.rear == Q.front){
        return false;
    }
    x = Q.data[Q.front];
    return true;
}
```

上面的判断队是否满的操作，是通过牺牲一个存储单元，入队时少使用一个存储单元，判断队尾的下一个元素是否为队头，这个判断方法很常用，但也有其他的方法。

可以再定义一个元素size，来表示队列当前的长度，size初始化为0，每入队一次，size++，每出队一次，size--

```C++
#define MAXSzie 10
typedef struct{
    ElemType data[MaxSize];   //静态数组存放队列元素
    int front,rear;           //队头指针和队尾指针
    int size;                 //队列长度
}SqQueue;
```

也可以设置一个变量tag，标记上一次的操作，删除为0，插入为1。已知只有删除操作才可能导致队空，只有插入操作才可能导致队满

```C++
#define MAXSzie 10
typedef struct{
    ElemType data[MaxSize];   //静态数组存放队列元素
    int front,rear;           //队头指针和队尾指针
    int tag;                 //队列长度
}SqQueue;

//队满的条件：
front == rear && tag == 1;  //头尾指针相遇且上次操作为插入

//队空的条件
front == rear && tag == 0;  //头尾指针相遇且上次操作为删除

```


&emsp;

&emsp;

&emsp;

上述都是假定队尾元素指向的是下一个应该插入的位置，假设题目说的是队尾指针指向的就是尾元素，插入操作前应该先让队尾指针前移一位,再写入数据元素，初始化时，尾指针也应该指向MaxSize-1这个位置

```C
//初始化
front = 0;
rear = MaxSize - 1;

//插入
Q.rear = (Q.rear + 1) % MaxSize;
Q.data[Q.rear] = x;

//判空:队尾下一个就是队头
(Q.rear + 1) % MaxSize == Q.front;

//判满,牺牲一个存储单元的方法
(Q.rear + 2) % MaxSize == Q.front;
```

### 链式存储

本质上就是一个同时带有队头指针和队尾指针的单链表。也有带头结点的和不带头结点的。

```C
//链式队列结点
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;

//链式队列
typedef struct{
    LinkNode *front,*rear; //队列的队头和队尾指针
}LinkQueue;
```


#### 链式存储实现

```C++
//带头结点

//初始化
void InitQueue(LinkQueue &Q){
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));  //初始化时，front和rear都指向头结点
    Q.front->next = NULL;
}

//判空
bool IsEmpty(LinkQueue Q){
    if(Q.front == Q.rear){
        return true;
    }
    else{
        return false;
    }
}

//入队
void EnQueue(LinkQueue &Q, ElemType x){
    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;   //开辟空间，初始化值
    s->next = NULL;   //创造出来的其实就是链表的尾
    Q.rear->next = s;  //新结点插入到rear之后
    Q.rear = s;        //修改表尾指针
}

//出队
bool DeQueue(LinkQueue &Q, ElemType &x){
    if(Q.front == Q.rear){  //队列判空
        return false;
    }

    LinkNode* p = Q.front->next; //对于带头结点的队列来说，front指向的是头，要删除的其实是头结点的下一个元素
    x = p->data;
    Q.front->next = p->next;  //修改头结点next指针
    if(Q.rear == p){
        //如果删除的是最后一个元素，还需要让尾结点也指向头结点
        Q.rear = Q.front;
    }
    free(p);
    return true;
}

```

```C++
//不带头结点

//初始化
void InitQueue(LinkQueue &Q){
    Q.front = NULL;
    Q.rear = NULL;
}

//判空
bool IsEmpty(LinkQueue Q){
    if(Q.front == NULL){
        return true;
    }
    else{
        return false;
    }
}

//入队
void EnQueue(LinkQueue &Q, ElemType x){
    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;

    if(Q.front == NULL){
        //不带头结点的话，需要单独处理第一次插入的场景，因为初始化时头尾都是NULL
        Q.front = s;
        Q.rear = s;
    }
    else{
        Q.rear->next = s;   //新结点插入rear之后
        Q.rear = s;         //修改rear指针
    }
}

//出队
bool DeQueue(LinkQueue &Q, ElemType &x){
    if(Q.front == NULL)
        return false;  //空队
    LinkNode* p = Q.front;   //p指向出队的结点
    x = p->data;
    Q.front = p->next;   //修改front指针
    if(Q.rear == p){
        //需要判断删除的是否为最后一个
        Q.front = NULL;
        Q.rear = NULL;
    }
    free(p);
    return true;
}

```

链式存储操作除非内存不足，否则不存在队满的情况。

## 双端队列

双端队列是两端都可以进行入队和出队操作的线性表。

+ 输入受限的双端队列：只允许一端插入，两端删除的线性表，做题时输入固定，看输出；
+ 输出首先的双端队列：只允许两端插入，一端删除的线性表，做题时输出固定，看输入；



## 基本操作

+ InitQueue(&Q):初始化队列，构造一个空队列；
+ DestroyQueue(&Q):销毁队列，释放空间；
+ EnQueue(&Q,x):入队；
+ DeQueue(&Q,&x):出队；
+ GetHead(Q,&x):读队头元素，队列的使用场景中，大多数只访问队头元素
+ QueueEmpty(Q):判断队列是否为空
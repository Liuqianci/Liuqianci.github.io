---
title: page
date: 2024-10-01 23:21:30
tags:
    - 数据结构
categories:
    - 考研初试
    - 数据结构
top: 50
---

# 栈

## 逻辑结构

栈是只允许在**一端进行**插入或删除操作的**线性表**。

几个术语：

+ 栈顶：线性表允许插入删除的那一端；
+ 栈底：固定的、不允许进行插入和删除的那一端；
+ 空栈：不含任何元素的空表； 
+ 特点：后进先出（LIFO）


![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png)



栈的常考题型：给定进栈顺序，判断有哪些合法的出栈顺序？n个不同元素进栈，出栈元素不同的排列顺序为$\frac{1}{n+1}C_{2n}^n$，称为卡特兰数。


## 存储结构

### 顺序存储

#### 顺序栈的实现

```C
#define MaxSize 10   //栈的最大个数
typedef struct{   
    ElemType data[MaxSize];   //静态数组存放栈的元素
    int top;                  //栈顶指针(数组下标)
}SqStack;

```



+ 栈顶指针：S.top，指向栈顶元素，可以理解为数组下标，初始时S.top=-1，栈顶元素表示为S.data&#91;S.top&#93;
+ 进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素；
+ 出栈操作：栈非空时，先找栈顶元素值，再将栈顶指针减1；
+ 栈空条件：S.top==-1
+ 栈满条件：S.top == MaxSize-1;栈长S.top+1;


#### 基本运算

栈的基本运算的时间复杂度都是$O(1)$

```C
//初始化
void InitStack(SqStack &S)
{
    S.top = -1;
}

//判空
bool StackEmpty(SqStack S)
{
    if(S.top == -1)
        return true;
    else
        return false;
}

//进栈
bool Push(SqStack &S, ElemType x)
{
    if(S.top == MaxSize -1)    //栈满了
        return false;

    S.top = S.top + 1;       //指针先+1
    S.data[S.top] = x;       //新元素再入栈
    return true;
}

//出栈  
//注意，出栈操作只是逻辑上被删除出栈了，但数据依旧残留在内存中
bool Pop(SqStack &S, ElemType &x)
{
    if(S.top == -1)    //栈空
        return false;

    x = S.data[S.top];    //栈顶元素先出栈
    S.top = S.top - 1;     //指针再减1
    return true;
}

//读栈顶元素
bool GetTop(SqStack S, ElemType &x)
{
    if(S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}

```

上述设计都是栈顶指针初始化为-1，即指向当前栈顶位置，此时入栈和出栈都需要先变更指针再操作数据；如果栈顶指针初始化为0，即指向下一个操作数的位置，那么正好相反，入栈和出栈需要先操作数据，再变更指针。


顺序栈的缺点：用静态数组存放元素，栈的大小不可改变。但如果我们一开始就分配非常大的地址空间，那么又会造成资源浪费。所以我们可以利用相对栈底位置不变的特性，让两个顺序栈公用一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延申。这个就是**共享栈**


![](https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B1%E4%BA%AB%E6%A0%88.png)


```C
#define Max 50
typedef struct{
    ElemType data[MaxSize];
    int top0;           //0号栈顶指针
    int top1;           //1号栈顶指针
}

//初始化
void InitStack(ShStack &S){
    S.top0 = -1;
    S.top1 = MaxSize;
}

```

+ top0=-1时，0号栈为空；top1=MaxSize时，1号栈为空；
+ 栈满条件：top0 + 1 == top1
+ 0号栈进栈时，top0先加1再赋值；1号栈进栈时，top1先减1再赋值；


共享栈目的：

+ 更好的利用存储空间；
+ 两个栈互相调节，只有再整个存储空间都被占满时才发生上溢；

### 链式存储

链式存储方式完全可以类比链表操作，只是规定了只能在链表的一端（表头）进行操作。一般规定链栈没有头结点，LHead直接指向栈顶元素。

```C++
typedef struct Linknode
{
    ElemType data;            //数据域
    struct Linknode* next;    //指针域
}*LiStack;
```


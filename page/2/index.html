<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liu-fb.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":2,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
<meta property="og:type" content="website">
<meta property="og:title" content="Fabian备忘录">
<meta property="og:url" content="https://liu-fb.com/page/2/index.html">
<meta property="og:site_name" content="Fabian备忘录">
<meta property="og:description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fabian">
<meta property="article:tag" content="C&#x2F;C++ Windows 网络 安全 摘抄">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://liu-fb.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Fabian备忘录</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband">
	<a target="_blank" rel="noopener" href="https://github.com/Liuqianci" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Fabian备忘录</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">人类资格证考核中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">类型转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-20 11:59:24" itemprop="dateCreated datePublished" datetime="2025-05-20T11:59:24+08:00">2025-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-05 11:03:54" itemprop="dateModified" datetime="2025-06-05T11:03:54+08:00">2025-06-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c语言的类型转换">C语言的类型转换</h1>
<h2 id="赋值转换">赋值转换</h2>
<p>  将一种类型的值赋给另一种类型的变量，此时值会转变为接收变量的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">3.14</span>;  <span class="comment">//3.14被截断为3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* ip;</span><br><span class="line">ip = <span class="number">0</span>;  <span class="comment">//0被转换为int*型的空指针</span></span><br></pre></td></tr></table></figure>
<p>  当把一个超出其范围的值赋给一个指定类型的对象时，不同的系统有不同的操作。将int类型的数赋值给short类型时，大多数系统将int的低字节赋值，高字节舍去：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> a = <span class="number">0x1111FFFF</span>; <span class="comment">//a的值为0xFFFF</span></span><br></pre></td></tr></table></figure>
<p>  当把一个取值范围小的值赋给取值范围大的值，会根据符号位自动补值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">0xe0</span>;</span><br><span class="line"><span class="type">int</span> b = a;  <span class="comment">//符号位是1，补1，此时b=0xffffffe0</span></span><br></pre></td></tr></table></figure>
<p> </p>
<h2 id="表达式转换">表达式转换</h2>
<p>  当同一个表达式中出现不同类型的量时，会根据不同的情况对操作数进行自动转换，这些转换可分为“整数提升”和“运算时的转换”：</p>
<ol type="1">
<li>整数提升：表达式计算时，bool、char、unsigned
char、short都会自动转换成int型，bool值类型中true转为1，false转为0；</li>
<li>运算时转换：运算涉及两种类型时，较小的类型(表达力低)会转换为较大的类型(表达力高)，表达力从低到高的排序为“int➡unsigned
int➡long➡unsigned long➡fload➡double➡long double”;</li>
</ol>
<p>  表达式转换时long和unsigned
int的转换需要注意，32位机器上long和int通常都是一个字长，所以表达式中包含unsigned
int和long两种类型时，这俩统一转换为unsigend long;</p>
<p>  表达式中出现同类型的signed和unsigned数时，统一转换为unsigned，只是把符号位当作数值位计算。比如int型的-1会转换为unsigned
int的<span
class="math inline">\(2^{32}-1\)</span>，这就是常说的溢出了。要注意此时内存中的内容并没有改变，只是解释不一样。</p>
<p> </p>
<h2 id="显式转换">显式转换</h2>
<p>  显示转换也称为强制类型转换，格式为“(类型说明符)(表达式)”，比如<kbd>double
f =
double(1)/double(2);</kbd>。基本类型的指针之间不含隐式转换（void*除外），都需要显示转换。</p>
<p> </p>
<h2 id="隐式转换">隐式转换</h2>
<p>  把一个表达式传递给一个函数调用、从函数中返回一个表达式会发生隐式类型转换.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> f = <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//虽然用double变量来接收结果，但表达式运算全是整型数，会转换为整形数的除法</span></span><br><span class="line"><span class="comment">//运算结果为0,转换为double后为0.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> f = <span class="number">1.0</span>/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//由于1.0是浮点型，所以2会发生隐式类型转换变为2.0，最终结果是0.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival;</span><br><span class="line"><span class="keyword">if</span>(ival) <span class="comment">//ival发生隐式类型转换为bool</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h1 id="c的类型转换">C++的类型转换</h1>
<h2 id="const_case">const_case</h2>
<p>  用于转换指针或引用，去掉类型的const属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const_case使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// C++ const_cast</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//int* pA = &amp;a;  //const int*类型不能用于初始化int*类型实体</span></span><br><span class="line">	<span class="type">int</span>* pA = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">	*pA = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意，虽然我们用指针把a的值改变了，实际上也确实改变了</span></span><br><span class="line"><span class="comment">//但假如我们要使用a的值，比如cout一下，那么a原来的值（10）会直接赋值到行为上</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;a&lt;&lt;endl；输出的结果是10，而不是100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h2 id="reinterpret_cast">reinterpret_cast</h2>
<p>  这是一种很危险的类型转换。既不检查指向的内容，也不检查指针类型本身，只是做了类型的重新解释。reinterpret_cast需要保证转换前后的类型所占用的内存大小一致，否则将引发编译时错误。</p>
<p>  虽然危险，但工程中的使用常见还是比较广泛，比如void*和其他类型的转换，遇到这种场景最好使用reinterpret_cast而不是C语言的强制类型转换，因为C语言的强制转换不做任何的检查。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reinterpret_cast使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// C++ reinterpret_cast</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*FuncPtr)</span> <span class="params">()</span></span>; <span class="comment">//定义函数指针，返回值void，参数也是void</span></span><br><span class="line"></span><br><span class="line">	FuncPtr funcPtr;</span><br><span class="line">	<span class="comment">//funcPtr = &amp;Test;  //两个函数模型不匹配，不能赋值</span></span><br><span class="line">	funcPtr = <span class="built_in">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;Test);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h2 id="static_case和dynamic_cast">static_case和dynamic_cast</h2>
<p>  用于基本的类型转换(这种方式就是类似于C语言的类型转换方式)。也可以用于有继承关系类对象和类指针之间的转换，但需要由程序员来确保转换是安全的，它不会产生动态转换的类型安全检查的开销，因为类型检查不是编译器能检测出来的，必须要等到运行时才能动态检查。</p>
<p>  dynamic_cast是为了弥补static_cast的不足，可以做类型的检查。它只能用于含有虚函数的类，必须用于多态体系中，用于类层次间的向上和向下转化；向下转化时，如果是非法的对于指针返回NULL。(向上转化：子类转换为父类；向下转化：父类转化为子类。子类转化为父类比较安全，但父类转化为子类不安全，因为子类一定有父类的属性，但父类未必有子类的属性)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static_cast 和 dynamic_cast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>() : _i(<span class="number">0</span>) &#123; ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">T</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:T&quot;</span> &lt;&lt; _i &lt;&lt; endl; &#125;  <span class="comment">//必须有虚函数，dynamic_cast才做检查</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>() :_j(<span class="number">1</span>) &#123; ; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">T</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:T&quot;</span> &lt;&lt; _j &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// static_cast</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i);  <span class="comment">//基本类型转换  int -&gt; double</span></span><br><span class="line">	<span class="type">double</span> d2 = <span class="number">5.6</span>;</span><br><span class="line">	<span class="type">int</span> i2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d2);  <span class="comment">//基本类型转换  double -&gt; int</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ii = <span class="number">5</span>;</span><br><span class="line">	<span class="type">double</span> dd = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(ii);</span><br><span class="line">	<span class="type">double</span> dd2 = <span class="number">5.6</span>;</span><br><span class="line">	<span class="type">int</span> ii2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dd2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// static_cast与dynamic_cast</span></span><br><span class="line"></span><br><span class="line">	Base cb;</span><br><span class="line">	Derived cd;</span><br><span class="line">	Base* pcb;</span><br><span class="line">	Derived* pcd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子类--》 父类</span></span><br><span class="line">	<span class="comment">// 这个是安全的</span></span><br><span class="line">	pcb = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;cd);</span><br><span class="line">	<span class="keyword">if</span> (pcb == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;unsafe static_cast from Derived to Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	pcb = <span class="built_in">dynamic_cast</span>&lt;Base*&gt;(&amp;cd);</span><br><span class="line">	<span class="keyword">if</span> (pcb == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast from Derived to Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 父类--》 子类</span></span><br><span class="line">	<span class="comment">// 这个有风险，dynamic_cast会做检查导致失败</span></span><br><span class="line">	pcd = <span class="built_in">static_cast</span>&lt;Derived*&gt;(&amp;cb);</span><br><span class="line">	<span class="keyword">if</span> (pcd == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;unsafe static_cast from Base to Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	pcd = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(&amp;cb);</span><br><span class="line">	<span class="keyword">if</span> (pcd== <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast from Base to Derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img
src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2.png" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB/" class="post-title-link" itemprop="url">避免头文件重复包含</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-19 01:09:01 / 修改时间：01:14:54" itemprop="dateCreated datePublished" datetime="2025-05-19T01:09:01+08:00">2025-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>184</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  为了避免一个文件被多次include，有两种方式：</p>
<ul>
<li>使用宏来防止同一个文件被多次包含
<ul>
<li>优点：可移植性好</li>
<li>缺点：无法防止宏名重复，难以排错</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SOMEFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SOMEFILE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>  </p>
<ul>
<li>使用编译器来防止同一个文件被多次包含
<ul>
<li>优点：可以防止宏名重复，易排错</li>
<li>缺点：可移植性不好，windows支持，其他平台未必</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" class="post-title-link" itemprop="url">C++面试问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-16 11:53:14" itemprop="dateCreated datePublished" datetime="2025-05-16T11:53:14+08:00">2025-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-19 01:40:21" itemprop="dateModified" datetime="2025-05-19T01:40:21+08:00">2025-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指针">指针</h1>
<h2 id="参数传递">参数传递</h2>
<p>下列程序是否正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">GetMemory</span>(str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误，程序崩溃。因为GetMemory 并不能传递动态内存， Test 函数中的 str
一直都是 NULL。strcpy(str, "hello world");将使程序崩溃。</p>
<p> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">GetMemory</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> p[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">	str = <span class="built_in">GetMemory</span>();</span><br><span class="line">	<span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能返回乱码。因为GetMemory
返回的是指向“栈内存”的指针，该指针的地址不是
NULL，但其原现的内容已经被清除，新内容不可知。</p>
<p> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="type">char</span> **p, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*p = <span class="keyword">new</span> <span class="type">char</span>[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">GetMemory2</span>(&amp;str, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能正常运行，但是内存泄漏。</p>
<p> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *str = <span class="keyword">new</span>  <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(str, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">delete</span>[ ] str;</span><br><span class="line">	<span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(str,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>篡改动态内存区的内容，后果难以预料，非常危险。因为 delete[
]str;之后，str成为野指针(需要str = NULL;)if(str !=
NULL)语句不起作用。</p>
<h1 id="编程">编程</h1>
<h2 id="不用c库函数自行实现strcpy">不用C++库函数，自行实现strcpy</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *strDest, <span class="type">const</span> <span class="type">char</span> *strSrc)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>((strDest!=<span class="literal">NULL</span>) &amp;&amp; (strSrc !=<span class="literal">NULL</span>));</span><br><span class="line"><span class="type">char</span> *address = strDest; </span><br><span class="line"><span class="keyword">while</span>( (*strDest++ = * strSrc++) != ‘\<span class="number">0</span>’ )</span><br><span class="line">  ;</span><br><span class="line"><span class="keyword">return</span> address ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">编程思想——泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-14 11:29:26" itemprop="dateCreated datePublished" datetime="2025-05-14T11:29:26+08:00">2025-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-06 20:52:27" itemprop="dateModified" datetime="2025-06-06T20:52:27+08:00">2025-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  泛型编程就是以独立于任何特定类型的方式编写代码。使用泛型程序时，我们需要提供具体程序实例操作的类型或只值。</p>
<p>  泛型编程和面向对象编程一样，都依赖于某种形式的多态性。</p>
<p>  面向对象编程中的多态性在运行时依赖存在继承关系的类。我们能够编写使用这些类的代码，忽略基类与派生类之间类型上的差异。只要使用基类的引用或指针，基类类型或派生类类型的对象就可以使用相同的代码。</p>
<p>  如果说面向对象是一种通过间接层来调用函数以换取一种抽象（创建一个接口类），那么泛型编程则是更直接的抽象，它不会因为间接层而损失效率。不同于面向对象的动态期多态，泛型编程是一种静态期多态，通过编译器生成最直接的代码。泛型编程可以将算法与特定类型、结构剥离，尽可能复用代码。标准库中的容器、迭代器和算法是很好的泛型编程的例子，几乎可以在任意类型上使用标准库的类和函数。</p>
<p>  C++中，模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。</p>
<h1 id="函数模板">函数模板</h1>
<p>  模板定义以关键字template开始，后接模板形参表。模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以逗号分隔。模板形参表不能为空。</p>
<p>  模板形参表很像函数形参表，函数形参表定义了特定类型的局部变量但并不初始化那些变量，在运行时再提供实参来初始化形参。同样，模板形参表示可以在类或函数的定义中使用的类型或值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个名为T的类型形参</span></span><br><span class="line"><span class="comment">//在callWithMax内部，可以使用名字T引用一个类型，具体表示哪个类型由编译器根据所用函数参数而确定</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callWithMax</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  类型形参T跟在关键字class或者typename之后定义，这里class和typename没有区别。模板形参可以是表示类型的类型形参，也可以是表示常量表达式的非类型形参。模板形参选择的名字没有本质含义。可以给模板形参赋予的唯一含义是区别形参是类型形参还是非类型形参。如果是类型形参，我们就知道该形参表示的是未知类型；如果是非类型形参，我们就知道他是一个未知值。<strong>模板非类型形参是模板定义内部的常量值</strong>。</p>
<p>  上面那个模板函数若再加上inline（不要放在template之前，要放在模板形参之后，返回类型之前），使其成为模板内联函数。这个模板内联函数可以用下列宏定义替换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);  <span class="comment">//这里a被累加两次</span></span><br><span class="line">CALL+<span class="built_in">WITH_MAX</span>(++a, b + <span class="number">10</span>); <span class="comment">//这里a被累加一次</span></span><br></pre></td></tr></table></figure>
<p>  由此可见，用模板内联函数可以避免宏定义中犯人的括号。而且还可以避免莫名其妙的情况，上面例子可见第一次运算的时候a的递增次数竟然依赖于它被拿来和谁比较。因此我们应该尽量少使用宏！！</p>
<p>  （宏定义和内联的区别：宏定义是在预处理阶段进行代码替换，内联函数是在编译阶段插入代码；其次宏没有类型检查，函数由类型检查）</p>
<p> </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型编程的主要工作不是程序员，而是编译器</span></span><br><span class="line"><span class="comment">编译器会在编译期间根据代码自动生成方法</span></span><br><span class="line"><span class="comment">由于大量工作是编译器操作，可能通用的泛型函数并不能满足我们的需求</span></span><br><span class="line"><span class="comment">所以我们通常还需要“特化”处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//特化</span></span><br><span class="line"><span class="comment">//如果是字符串的话特殊处理</span></span><br><span class="line"><span class="comment">//其余的输入可以让输入类型不相同，返回值统一为int</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">max</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ?  (a) : (b));</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a &gt; b ? a : b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//调用函数</span></span><br><span class="line">    <span class="type">char</span>* s1 = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="type">char</span>* s2 = <span class="string">"world"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(s1, s2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">4.5</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  泛型编程是把算法和具体的数据结构分开了，我们不需要考虑类型本身是什么，直接用一套逻辑把所有的类型都涵盖了，如果需要针对某些特殊类型做处理，我们就进行单独的“特化”。这里比较复杂的操作是编译器的推理过程，程序员所做的工作无非是把该定义好的类型通知编译器，让编译器帮助我们做处理。</p>
<p> </p>
<h1 id="类模板">类模板</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>();</span><br><span class="line">    <span class="function">Type &amp;<span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Type &amp;<span class="title">front</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> Type&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="type">int</span>&gt; q1;  <span class="comment">//必须显式指定实参</span></span><br></pre></td></tr></table></figure>
<p>  使用类模板时，必须为模板形参显式指定实参，编译器使用实参来实例化这个类的特定类型版本，重新编写Queue类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">泛型编程的思想可以做一些算法优化，比如下面的等差数列求和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1+2+3...+100 ==&gt; n*(n+1)/2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用泛型不是用泛型编程可以传递广泛类型的属性，这里直接定义了int</span></span><br><span class="line"><span class="comment">//这里是借用泛型编程的另一个特征：编译期推理，让程序自动生成代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> n&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// 递推的思路，求前n个数的和可以表示为前(n-1)个数的和+n</span></span><br><span class="line"><span class="comment">// Sum(n) = Sum(n-1)+n</span></span><br><span class="line"><span class="comment">// 这里声明一个enum的成员，内部的枚举值是N，N的计算方法是递归求和</span></span><br><span class="line"><span class="comment">// 利用泛型编程的自动推理完成编译期计算</span></span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Value</span> {</span><br><span class="line">        N = Sum&lt;n<span class="number">-1</span>&gt;::N+n</span><br><span class="line">	};</span><br><span class="line">};</span><br><span class="line"><span class="comment">//下面这个就是递推的基准点，n=1的特化</span></span><br><span class="line"><span class="comment">// 如果不设置，那么就会无穷递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum</span>&lt;<span class="number">1</span>&gt;</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">enum</span> <span class="title class_">Value</span> {N = <span class="number">1</span>};    <span class="comment">// n=1</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//这里只需要输出结果就行，运算过程中在编译期就完成了</span></span><br><span class="line">    cout &lt;&lt; Sum&lt;<span class="number">100</span>&gt;::N &lt;&lt; endl; <span class="comment">//计算1+2+……+99+100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p> </p>
<p>  <strong>模板编程的难点很大程度上在于对编译器的理解，我们需要直到怎么帮助编译器提供需要生成代码的信息。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">编程思想——设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-14 11:28:34" itemprop="dateCreated datePublished" datetime="2025-05-14T11:28:34+08:00">2025-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-20 20:18:16" itemprop="dateModified" datetime="2025-05-20T20:18:16+08:00">2025-05-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式">设计模式</h1>
<p>  一个模式描述了一个不断发生问题及这个问题的解决方案；模式是前人的设计经验上总结出来的对于一些普遍存在的问题提供的通用解决方案，比如单例模式、观察者模式等；</p>
<p>  软件工程中有很多模式，面向对象常见的有23种设计模式，可以分为创建型(单例)，结构型(适配器)和行为型(观察者)模型。设计模式不是万能的，它建立在系统变化点上，哪里有变化哪里就可以用。设计模式是为了解耦合，为了扩展，它通常是演变过来的，需要演变才能准确定位。设计模式是一种软件设计方法，不是标准，面目前大部分框架中都包含了大量的设计模式思想。</p>
<p>  </p>
<h1 id="单例模式">单例模式</h1>
<p>  有些时候，我们需要整个程序中有且只有一个实例，比如系统日志、Windows资源管理器窗口，数据库分配主键等操作。单例的实现思路：</p>
<ol type="1">
<li>Singleton拥有一个私有的构造函数，确保用户无法通过new直接实例它；</li>
<li>包含一个静态私有成员变量instance与静态公有方法Instance()，让外部通过Instance()来获取实例；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//只有静态的方法才能访问静态的变量</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">const</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"Do Something"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">// 将构造和析构函数私有化，防止外部访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>();</span><br><span class="line">	~<span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态变量帮助解决资源的分配和释放</span></span><br><span class="line"><span class="comment">// 肯定不能使用栈上的对象，不然会销毁</span></span><br><span class="line"><span class="comment">// 如果使用堆上的对象，在getInstance()方法中new出来，那就涉及到资源释放问题</span></span><br><span class="line"><span class="comment">// 析构函数是private的，外部是无法直接释放的</span></span><br><span class="line"><span class="comment">// 静态变量在程序中属于全局区，但声明了private后可见区域只在类内</span></span><br><span class="line"><span class="comment">// 所以可以让这个实例随着程序的产生而产生，随着程序的灭亡而灭亡</span></span><br><span class="line">	<span class="type">static</span> Singleton* This; </span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::This = <span class="literal">nullptr</span>;  <span class="comment">//静态变量需要显式声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//这里只是简化了，还需要考虑多线程的情况</span></span><br><span class="line">	<span class="keyword">if</span> (!This)</span><br><span class="line">	{</span><br><span class="line">		This = <span class="keyword">new</span> Singleton;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> This;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	Singleton::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line"></span><br><span class="line">	Singleton::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  上面的单例模式实现，程序开始时全局实例Singleton*
Singleton::This为空，只有我们主动调用Singleton::getInstance()-&gt;DoSomething()方法时才会产生这个对象的实例。我们也可以采用饿汉的方式，程序启动时就创建实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton.cpp</span></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::This = <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">//这里直接new</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//这里只是简化了，还需要考虑多线程的情况</span></span><br><span class="line">	<span class="keyword">if</span> (!This)</span><br><span class="line">	{</span><br><span class="line">		This = <span class="keyword">new</span> Singleton;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> This;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Singleton::~<span class="built_in">Singleton</span>()</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<h1 id="观察者模式">观察者模式</h1>
<p>  在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出相应；对象通常是一对多关系。常见于各种MVC的框架中，Model的变化通知各种类型的View时几乎都存在这种模式。</p>
<p>  观察者模式的实现思路：把问题的职责解耦合，将Observable和Observer抽象开，分清抽象和实体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Observer</span>() { ; }</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() { ; }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当被观察对象发生变化时，通知被观察者调用这个方法</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">void</span>* pArg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p><strong>用list列表来存储被观察清单。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被观察对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observerable</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Observerable</span>();</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Observerable</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注册观察者(加入被观察列表)</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">(Observer* pOb)</span></span>;</span><br><span class="line">	<span class="comment">// 反注册观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Detach</span><span class="params">(Observer* pOb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">GetObseverCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> _Obs.<span class="built_in">size</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">DetachAll</span><span class="params">()</span>  <span class="comment">//清理所有订阅者</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		_Obs.<span class="built_in">clear</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetSomeNews</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">SetChange</span>(str);</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">SetChange</span><span class="params">(string news)</span></span>;   <span class="comment">// 有变化，需要通知</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 通知观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Notify</span><span class="params">(<span class="type">void</span>* pArg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> _bChange;</span><br><span class="line">	list&lt;Observer*&gt; _Obs;  <span class="comment">//观察对象列表</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册观察者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Attach</span><span class="params">(Observer* pOb)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (pOb == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 看看当前列表中是否有这个观察者</span></span><br><span class="line">	<span class="keyword">auto</span> it = _Obs.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != _Obs.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (*it == pOb)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_Obs.<span class="built_in">push_back</span>(pOb);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反注册观察者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Detach</span><span class="params">(Observer* pOb)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((pOb == <span class="literal">NULL</span>) || (_Obs.<span class="built_in">empty</span>() == <span class="literal">true</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_Obs.<span class="built_in">remove</span>(pOb);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::SetChange</span><span class="params">(string news)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	_bChange = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Notify</span>( ( (<span class="type">void</span>*)news.<span class="built_in">c_str</span>() ));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observerable::Notify</span><span class="params">(<span class="type">void</span>* pArg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (_bChange == <span class="literal">false</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 看看当前列表中是否有这个观察者</span></span><br><span class="line">	<span class="keyword">auto</span> it = _Obs.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != _Obs.<span class="built_in">end</span>(); it++)</span><br><span class="line">	{</span><br><span class="line">		(*it)-&gt;<span class="built_in">Update</span>(pArg);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	_bChange = <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//被观察对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">News</span> : <span class="keyword">public</span> Observerable</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">GetSomeNews</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="built_in">SetChange</span>(<span class="string">"News: "</span> + str);</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User1</span>:<span class="keyword">public</span> Observer</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">void</span>* pArg)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"User1 Got News: "</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(pArg) &lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2</span> :<span class="keyword">public</span> Observer</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">void</span>* pArg)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"User2 Got News: "</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(pArg) &lt;&lt;endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    User1 u1;</span><br><span class="line">    User2 u2;</span><br><span class="line"></span><br><span class="line">    News n1;</span><br><span class="line">    n1.<span class="built_in">GetSomeNews</span>(<span class="string">"t0"</span>); <span class="comment">//此时没人订阅，什么事情都不会发生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅</span></span><br><span class="line">    n1.<span class="built_in">Attach</span>(&amp;u1);</span><br><span class="line">    n1.<span class="built_in">Attach</span>(&amp;u2);</span><br><span class="line">    n1.<span class="built_in">GetSomeNews</span>(<span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">    n1.<span class="built_in">Detach</span>(&amp;u2);</span><br><span class="line">    n1.<span class="built_in">GetSomeNews</span>(<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  观察者模式帮助我们把职责关系梳理清晰了，我们如果要增加一个新的观察者，直接继承一个Observer类，实现一下消息更新的虚方法即可。</p>
<p> </p>
<h1 id="适配器adapter模式">适配器(Adapter)模式</h1>
<p>  适配器模式可以理解为一个插口转换器，去不同国家旅游时可以适配不同的插座接口。适配器将类接口转换为客户端期望的另一个接口，让接口更兼容。适配器模式的动机是：如果可以更改接口，则可以重用现有的软件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器模式</span></span><br><span class="line"><span class="comment">//场景：</span></span><br><span class="line"><span class="comment">// 已经有一个矩形处理类LegacyRectangle，可以画一个矩形</span></span><br><span class="line"><span class="comment">// 此时收到需求，在画矩形之前需要额外输入一些别的东西，原有的LegacyRectangle类不能满足需求</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始的矩形处理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LegacyRectangle</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LegacyRectangle</span>(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)</span><br><span class="line">	{</span><br><span class="line">		_x1 = x1;</span><br><span class="line">		_y1 = y1;</span><br><span class="line">		_x2 = x2;</span><br><span class="line">		_y2 = y2;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LegacyDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"LegacyRectangle:: LegacyDraw()"</span> &lt;&lt; _x1 &lt;&lt; <span class="string">" "</span> &lt;&lt; _y1 &lt;&lt; <span class="string">" "</span> &lt;&lt; _x2 &lt;&lt; <span class="string">" "</span> &lt;&lt; _y2 &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _x1;</span><br><span class="line">	<span class="type">double</span> _y1;</span><br><span class="line">	<span class="type">double</span> _x2;</span><br><span class="line">	<span class="type">double</span> _y2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个抽象类和外部对接，让外部去调用这个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建内部接口，来实现对原始LegacyRectangle代码的复用</span></span><br><span class="line"><span class="comment">//有两种方式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种适配的方式：使用多重继承，把原始的类一并继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter</span>: <span class="keyword">public</span> Rectangle, <span class="keyword">public</span> LegacyRectangle</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RectangleAdapter</span>(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> w, <span class="type">double</span> h) :</span><br><span class="line">		<span class="built_in">LegacyRectangle</span>(x, y, x + w, y + h)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"RectangleAdapter(int x, int y, int w, int h)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"RectangleAdapter::Draw()"</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">LegacyDraw</span>();  <span class="comment">//实际使用的还是原始的方法</span></span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种适配的方式：组合方式的Adapter，把原始的类当作成员变量</span></span><br><span class="line"><span class="comment">// 这种方式更常见，因为可以避免多重继承方式的强耦合性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleAdapter2</span> :<span class="keyword">public</span> Rectangle</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">RectangleAdapter2</span>(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> w, <span class="type">double</span> h) :</span><br><span class="line">		_lRect(x, y, x + w, y + h)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"RectangleAdapter2(int x, int y, int w, int h)"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="string">"RectangleAdapter2::Draw()"</span> &lt;&lt; endl;</span><br><span class="line">		_lRect.<span class="built_in">LegacyDraw</span>();</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LegacyRectangle _lRect;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> x = <span class="number">20.0</span>, y = <span class="number">50.0</span>, w = <span class="number">300.0</span>, h = <span class="number">200.0</span>;</span><br><span class="line">	<span class="comment">//实际创建的是适配器对象，但接口调用用的是Rectangle接口类</span></span><br><span class="line">	<span class="function">RectangleAdapter <span class="title">ra</span><span class="params">(x, y, w, h)</span></span>;  </span><br><span class="line">	Rectangle* pR = &amp;ra;    </span><br><span class="line">	pR-&gt;<span class="built_in">Draw</span>(<span class="string">"Testing Adapter"</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">RectangleAdapter2 <span class="title">ra2</span><span class="params">(x, y, w, h)</span></span>;</span><br><span class="line">	Rectangle* pR2 = &amp;ra2;</span><br><span class="line">	pR2-&gt;<span class="built_in">Draw</span>(<span class="string">"Testing2 Adapter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">文件操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-14 11:27:17" itemprop="dateCreated datePublished" datetime="2025-05-14T11:27:17+08:00">2025-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-19 01:40:24" itemprop="dateModified" datetime="2025-05-19T01:40:24+08:00">2025-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>  计算机程序的输入流起点和输出流的终点都可以是磁盘文件。C++把每个文件都看成是一个有序的字节序列，每个文件都以文件结束标志结束。</p>
<p>  按照文件中数据的组织形式可以把文件分为：</p>
<ol type="1">
<li>文本文件：文件中信息形式为ASCII码文件，每个字符占用一个字节；</li>
<li>二进制文件：文件中信息的形式与其在内存中的形式相同；</li>
</ol>
<p>  </p>
<p>文件操作步骤：</p>
<ol type="1">
<li>打开文件open；</li>
<li>检查打开是否成功；</li>
<li>读或写read\write；</li>
<li>检查是否读完EOF（end of file）；</li>
<li>使用完文件后关闭文件close;</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把输入的字符信息写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fstream fout;</span><br><span class="line">    fout.<span class="built_in">open</span>(<span class="string">"test.txt"</span>, ios::app);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //可以直接这么写，程序会默认打开</span></span><br><span class="line"><span class="comment">    fstream fout("test.txt");   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fout.<span class="built_in">fail</span>())  <span class="comment">//也可以判断fout是否非空：if(!fout)</span></span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"open fail"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a)</span><br><span class="line">    {</span><br><span class="line">        fout &lt;&lt; <span class="string">"The numbers are:"</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">//用定义的fout输出到文件</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">5</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fout.<span class="built_in">close</span>();  <span class="comment">//关闭文件</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">文件打开方式</th>
<th style="text-align: left;">行为</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ios::in</td>
<td style="text-align: left;">ifstream的默认模式，打开文件进行读操作</td>
</tr>
<tr class="even">
<td style="text-align: left;">ios::out</td>
<td style="text-align: left;">ofstream的默认方式，打开文件进行写操作</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ios::ate</td>
<td style="text-align: left;">打开一个已经有输入或输出文件并查找到文件尾</td>
</tr>
<tr class="even">
<td style="text-align: left;">ios::app</td>
<td style="text-align: left;">打开文件以便在文件的尾部添加数据</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ios::nocreate</td>
<td style="text-align: left;">如果文件不存在，则打开操作失败</td>
</tr>
<tr class="even">
<td style="text-align: left;">ios::trunc</td>
<td style="text-align: left;">如果文件存在，清除文件原有内容(默认)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ios::binary</td>
<td style="text-align: left;">以二进制方式打开</td>
</tr>
</tbody>
</table>
<p>  </p>
<p>  文件的默认打开方式是ASCII，如果需要以二进制方式打开，需要设置ios::binary：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制的方式拷贝一个文件：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> bufferLen = <span class="number">2048</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CopyFile</span><span class="params">(<span class="type">const</span> string&amp; src, <span class="type">const</span> string&amp; dst)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 打开源文件和目标文件</span></span><br><span class="line">	<span class="comment">// 源文件以二进制读的方式打开</span></span><br><span class="line">	<span class="comment">// 目标文件以二进制写的方式打开</span></span><br><span class="line">	<span class="function">ifstream <span class="title">in</span><span class="params">(src.c_str(), ios::in | ios::binary)</span></span>;</span><br><span class="line">	<span class="function">ofstream <span class="title">out</span><span class="params">(dst.c_str(), ios::out | ios::binary | ios::trunc)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断文件打开是否成功，失败返回false</span></span><br><span class="line">	<span class="keyword">if</span> (!in || !out)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从源文件中读取数据，写到目标文件中</span></span><br><span class="line">	<span class="comment">// 通过读取源文件的EOF来判断读写是否结束</span></span><br><span class="line">	<span class="comment">// 分块读取，不要一下全读进来，防止缓冲区不够用</span></span><br><span class="line">	<span class="type">char</span> temp[bufferLen];</span><br><span class="line">	<span class="keyword">while</span> (!in.<span class="built_in">eof</span>())</span><br><span class="line">	{</span><br><span class="line">		in.<span class="built_in">read</span>(temp, bufferLen);</span><br><span class="line">		streamsize count = in.<span class="built_in">gcount</span>(); <span class="comment">//实际读的大小</span></span><br><span class="line">		out.<span class="built_in">write</span>(temp, count);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭源文件和目标文件</span></span><br><span class="line">	<span class="comment">// 如果不关闭会导致资源泄露</span></span><br><span class="line">	in.<span class="built_in">close</span>();</span><br><span class="line">	out.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">CopyFile</span>(<span class="string">"AA.mp3"</span>, <span class="string">"BB.mp3"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/IO%E6%B5%81%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/IO%E6%B5%81%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">IO流基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-14 11:24:14" itemprop="dateCreated datePublished" datetime="2025-05-14T11:24:14+08:00">2025-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-17 11:29:56" itemprop="dateModified" datetime="2025-05-17T11:29:56+08:00">2025-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="io流">I/O流</h1>
<p>  传统的C语言中I/O处理有printf，scanf，getch，gets等函数，他们的问题是不可编程，仅仅能识别内置的数据类型，无法识别自定义的数据类型；而且代码移植性差，有很多坑。</p>
<p>  C++中有I/O流istream，ostream等处理方式，可编程，对于类库的设计者来说很有用；而且还能简化编程，使I/O的风格保持一致。</p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/IO%E6%B5%811.png"></p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/IO%E6%B5%812.png"></p>
<p> </p>
<h1 id="io缓存区">IO缓存区</h1>
<p>  计算机发展过程中，需要实现外部的设备可以用统一的标准和计算机程序进行交互。最早的UNIX系统是以文件的方式进行交互。这个思想发展到现在就是IO缓存区。因为外部设备和内存的速度是不一样的，缓存区的存在可以让我们的信息读取更加高效。</p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/IO%E6%B5%813.png"></p>
<p>标准的IO提供三种类型的缓存模式：</p>
<ol type="1">
<li>按块缓存：如文件系统，一次性加载到内存中</li>
<li>按行缓存：以''区分行</li>
<li>不缓存</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"The numbers are:"</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">5</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the last char is:"</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/IO%E6%B5%814.png"></p>
<p>  上面代码一连输入6个int，内部接收完5个数字后循环结束，但可以看到6还是读入了，并且以char的形式输出，后面的ch还没来得及输入程序就退出了。这是程序中面临的一个问题，输入的6被暂存到缓冲区中成为了脏数据，在我们不之情的情况下把后面的输入给覆盖掉了。</p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/IO%E6%B5%815.png"></p>
<p> </p>
<p>我们可以使用cin::ignore(int count,type
metadelim)方法来清空缓冲区，第一个参数是要清空多少缓冲区信息，第二个参数表达以什么符号作为结尾</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空缓冲区</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"The numbers are:"</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">5</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空缓冲区脏数据</span></span><br><span class="line">    <span class="comment">//numeric_limits&lt;std::streamsize&gt;::max()表示缓冲区的最大范围</span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">'\n'</span>); </span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the last char is:"</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">面向对象编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-14 10:29:14" itemprop="dateCreated datePublished" datetime="2025-05-14T10:29:14+08:00">2025-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-06 11:24:40" itemprop="dateModified" datetime="2025-06-06T11:24:40+08:00">2025-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类">类</h1>
<p>  C++使用struct、class来定义一个类：struct的默认成员权限是public，class的默认成员权限是private；除此之外，二者基本无差别。类的成员函数以及友元函数可以访问类中的所有成员，类外通过类的对象只能访问公有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetSorce</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<p>上面学生的类并不是真实世界中的学生，只是一个抽象的概念，并不包含真实世界中学生的所有属性，只是把一些属性抽象出来。</p>
<p> </p>
<h2 id="成员函数">成员函数</h2>
<p>  类的内部，声明成员函数是必须的，但定义成员函数是可选的。类体内部定义的函数默认为inline。</p>
<p>  调用成员函数时，实际上是使用对象来调用的。每个成员函数(除了static成员函数)都有一个额外的、隐含的形参this。在调用成员函数时，形参this初始化为调用函数的对象地址。程序员在成员函数中处理非静态数据成员时，隐式的类对象就会发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle::SetLength</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	len += a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上len的存取是经过this完成的，这个函数的参数可以理解为：</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle::SetLength</span><span class="params">(rectangle* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">this</span> -&gt; len += a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="构造函数">构造函数</h2>
<p>  构造函数是特殊的成员函数，和类同名且没有返回类型。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。</p>
<p>  若没有为一个类显式定义任何构造函数，编译器将自动为这个类生成默认的构造函数，默认构造函数不带参数。若编译器自动生成默认构造，或者程序员自己定义了一个未进行任何操作的默认构造，则类中的每个成员使用与初始化变量相同的规则来进行初始化：1）类成员运行该类的默认构造函数来初始化；2）内置类型或者符合类型的成员初始值依赖作用域，局部作用域中这些成员不被初始化、全局作用域中它们被初始化为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">	<span class="type">int</span> score;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Student a; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	student b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//name是string类型的，所以a对象和b对象都调用string的默认构造</span></span><br><span class="line"><span class="comment">//score和number是内置类型，依赖作用域：</span></span><br><span class="line"><span class="comment">//a是全局对象，score和number初始化为0</span></span><br><span class="line"><span class="comment">//b是局部对象，number和score为垃圾值</span></span><br></pre></td></tr></table></figure>
<p> </p>
<p>  某些情况下，默认构造函数是被编译器隐式应用的，如果程序员定义了其他构造函数，编译器将不合成默认的构造函数，如果我们不定义默认的构造函数，该类的使用将受限。假设一个NoDefault的类定义了一个有string实参的构造函数，却不定义默认构造，那么：</p>
<ol type="1">
<li>所有包含NoDefault对象成员的类的构造函数，必须在成员初始化列表中通过传递一个初始的string给Nodefault构造函数来显式的初始化Nodefault成员；</li>
<li>编译器不再为含有NoDefault类型成员的类合成默认构造函数，程序员必须显式定义默认构造，且默认构造中必须显式的初始化其NoDefault成员；</li>
<li>NoDefault类型不能用作动态分配数组的元素类型；</li>
<li>NoDefault类型的静态分配数组必须为每一个元素提供一个显式的初始化式；</li>
<li>如果一个容器比如vector保存NoDefault对象，那么就不能使用接受容器大小而没有同时提供一个元素初始化式的构造函数；</li>
</ol>
<p> </p>
<h3 id="成员初始化列表">成员初始化列表</h3>
<p>  构造函数后面可以接初始化列表，为类的一个或多个数据成员指定初值。需要注意，C++中成员变量的初始化顺序与变量在类型中声明的顺序相同，而和它们在初始化列表中的顺序无关！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>():<span class="built_in">j</span>(<span class="number">0</span>),<span class="built_in">i</span>(j+<span class="number">2</span>){};</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="comment">//声明顺序是先i后j</span></span><br><span class="line">		<span class="comment">//所以哪怕初始化列表中先写j的值，也是先初始化i</span></span><br><span class="line">		<span class="comment">//所以现在i中是个垃圾值，这里没办法输出</span></span><br><span class="line">		cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  可以不使用初始化列表，而是在构造函数中为成员赋值，不过这样做效率会有点低。从概念上讲，构造函数的执行阶段分为两步：第一步是初始化阶段；第二步是计算赋值阶段。普通的内置类型成员由于不进行隐式初始化，所以无论使用初始化列表还是在构造函数中赋值都无关紧要，但如果是一个类成员，不在初始化列表中进行显式初始化，而是在构造函数函数体里赋值，相当于先调用这个类成员自身的构造函数进行初始化，然后再走赋值赋值操作，多了一个步骤。</p>
<p>  没有默认构造函数的类类型的成员变量、const类型的成员变量、引用类型的成员变量必须在构造函数初始化列表中进行初始化。</p>
<p> </p>
<h3 id="复制拷贝构造函数">复制(拷贝)构造函数</h3>
<p>  复制构造函数、赋值操作符和析构函数总称为复制控制，编译器会自动实现操作，不过程序员可以定义自己的版本。一个有用的经验：如果一个类需要析构函数，那么它也同时需要赋值操作符和复制构造函数。通常编译器自己合成的复制构造函数非常精炼，只做必需的工作。</p>
<p>  只有单个形参，而且该形参是对本类类型对象的引用（常用const修饰），这样的构造函数称为复制构造函数或拷贝构造函数。复制构造函数的作用：</p>
<ol type="1">
<li>根据另一个同类型的对象初始化一个对象；</li>
<li>复制一个对象，将它作为实参传给一个函数或从函数返回时复制一个对象；</li>
<li>初始化顺序容器中的元素；</li>
<li>根据元素初始化式列表初始化数组元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 根据另一个同类型的对象初始化一个对象:</span></span><br><span class="line"><span class="comment">//C++有两种初始化方式，复制初始化使用"="符号，直接初始化将初始化式放在圆括号中</span></span><br><span class="line"><span class="function">string <span class="title">dots</span><span class="params">(<span class="number">10</span>, <span class="string">'.'</span>)</span></span>; <span class="comment">//直接初始化</span></span><br><span class="line">string dots2 = <span class="string">"."</span>;  <span class="comment">//复制初始化，不过很多编译器会优化</span></span><br><span class="line"><span class="function">string <span class="title">dots3</span><span class="params">(dots)</span></span>;	<span class="comment">//也是复制初始化，用另一个本对象初始化自己</span></span><br><span class="line">string dot4 = dots;	<span class="comment">//也是复制初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制初始化的步骤：首先使用指定的构造函数创建一个临时对象，</span></span><br><span class="line"><span class="comment">//然后把临时对象复制到正在创建的对象中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要注意区分"="什么时候是复制初始化，什么时候是赋值操作符：</span></span><br><span class="line">string null_book = <span class="string">"9-999-9999-9"</span>;</span><br><span class="line">string null_book2;	<span class="comment">//语句1</span></span><br><span class="line">null_book2 = null_book; <span class="comment">//语句2</span></span><br><span class="line"><span class="comment">//这里语句1是调用string的默认构造函数创建一个空字符串对象</span></span><br><span class="line"><span class="comment">//语句2是利用赋值运算符将null_book赋值给null_book2，不是复制构造</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 复制一个对象，将它作为实参传给一个函数或从函数返回时复制一个对象:</span></span><br><span class="line"><span class="comment">//当形参或返回值是自定义类类型时，将由复制构造函数进行复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyClass</span>(<span class="type">int</span> n) { number = n; }</span><br><span class="line">	<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other){</span><br><span class="line">		<span class="comment">//拷贝构造中打印</span></span><br><span class="line">		number = other.number;</span><br><span class="line">		cout &lt;&lt; <span class="string">"a "</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> number;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(MyClass p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">MyClass <span class="title">temp</span><span class="params">(p)</span></span>;	<span class="comment">//第三次拷贝构造</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">obj2</span><span class="params">(<span class="number">0</span>)</span></span>;	<span class="comment">//默认构造</span></span><br><span class="line">	<span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>;	<span class="comment">//第一次拷贝构造</span></span><br><span class="line">	<span class="built_in">fun</span>(obj3);	<span class="comment">//实参obj3到形参p，第二次拷贝构造</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终结果输出“a a a”,调用3次拷贝构造</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 初始化顺序容器中的元素:</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器首先使用string的默认构造函数来创建一个临时值初始化svec</span></span><br><span class="line"><span class="comment">//然后使用复制构造函数将临时值复制到svec中的每一个元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 根据元素初始化式列表初始化数组元素:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类类型数组如果没有初始化式，则将用默认构造函数初始化每个元素；</span></span><br><span class="line"><span class="comment">//但如果使用花括号初始化列表来显式初始化数组，则使用复制初始化构造来初始化每个元素</span></span><br><span class="line"></span><br><span class="line">Sales_item_primer_eds[] = {</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"0-201-16487-6"</span>),</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"0-201-54848-7"</span>),</span><br><span class="line">	<span class="built_in">string</span>(<span class="string">"0-201-82470-1"</span>)</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p> </p>
<p>  复制构造函数参数必须是引用，如果不用引用，那就变成了值传递。值传递方式会调用该类的拷贝构造函数，从而造成无穷递归的调用拷贝构造。</p>
<p> </p>
<h3 id="深拷贝浅拷贝">深拷贝、浅拷贝</h3>
<ul>
<li>浅拷贝：只拷贝指针地址，对所有对原对象的引用仍然指向原对象，C++默认拷贝构造函数与赋值运算符重载都是浅拷贝；节省空间，但容易引发多次释放；</li>
<li>深拷贝：重新分配堆内存，拷贝指针指向内容，且引用原对象的变量将指向被复制的新对象；浪费空间，但是不会导致多次释放；</li>
</ul>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>{</span><br><span class="line">	<span class="type">char</span>* ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shallow_copy</span><span class="params">(Test&amp; src, Test&amp; dest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	dest.ptr = src.ptr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deep_copy</span><span class="params">(Test&amp; src, Test&amp; dest)</span></span>{</span><br><span class="line">	dest.ptr = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src.ptr) + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(dest.ptr, src.ptr);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  深拷贝的思想比较常见，比如C++的一个优化策略叫<strong>写时复制</strong>。有个信息存放在内存空间中，如果大家都去读取，那么内存中保留一份即可，但如果有地方需要写数据，那么会复制出一个新的地址空间存放相同数据，写操作作用在新地址空间上。</p>
<p>  深拷贝和浅拷贝各有优劣，如果想兼有二者的优点，有两种可用方案：第一是使用引用计数，用shared_ptr的思路，每有一个指针指向对象，引用计数+1，直到引用计数清零时再清理内存；第二种是C++11的新标准移动语义move，把资源让渡，既可以避免重新创建空间，也防止空间释放导致新问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义字符串类String操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="literal">NULL</span>);						<span class="comment">// 普通构造函数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String &amp;other);						<span class="comment">// 拷贝构造函数(深拷贝)</span></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; other);							<span class="comment">// 移动构造函数，两个&amp;&amp;代表右值引用</span></span><br><span class="line">	~<span class="built_in">String</span>(<span class="type">void</span>);									<span class="comment">// 析构函数</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span>= (<span class="type">const</span> String&amp; other);			<span class="comment">// 赋值函数</span></span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(String&amp;&amp; rhs)<span class="keyword">noexcept</span>;			<span class="comment">// 移动赋值运算符</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String &amp;c); 		<span class="comment">// cout输出</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *m_data; <span class="comment">// 用于保存字符串</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的普通构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (str == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			*m_data = <span class="string">'\0'</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];  <span class="comment">//把'\0'的空间留出来</span></span><br><span class="line">		<span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="comment">// 开辟新的内存空间了，属于深拷贝</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;other)</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(String&amp;&amp; other)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (other.m_data != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 资源让渡</span></span><br><span class="line">		m_data = other.m_data;</span><br><span class="line">		<span class="comment">// 之前的联接断开</span></span><br><span class="line">		other.m_data = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值函数</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>= (<span class="type">const</span> String &amp;other)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 释放原有的内容</span></span><br><span class="line">	<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	<span class="comment">// 重新分配资源并赋值</span></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值运算符</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(String&amp;&amp; rhs)<span class="keyword">noexcept</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">// 清空原有的</span></span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//赋值新的</span></span><br><span class="line">		m_data = rhs.m_data;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 我们接管了内存，原有内存不需要释放，把链接断开即可</span></span><br><span class="line">		rhs.m_data = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (m_data != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">delete</span>[] m_data;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> String &amp;c)</span><br><span class="line">{</span><br><span class="line">	os &lt;&lt; c.m_data;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="function">String <span class="title">s1</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;				<span class="comment">// 构造函数</span></span><br><span class="line">	cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//String s2 = s1;				// 调用拷贝构造函数</span></span><br><span class="line">	<span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;					<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">	<span class="function">String <span class="title">s2A</span><span class="params">(std::move(s1))</span></span>;		<span class="comment">// 移动构造函数</span></span><br><span class="line">	cout &lt;&lt; s2A &lt;&lt; endl;</span><br><span class="line">	String s3;						<span class="comment">// 无参构造函数</span></span><br><span class="line">	cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">	s3 = s2;						 <span class="comment">// 调用赋值函数</span></span><br><span class="line">	cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">	String s3A;						<span class="comment">// 无参构造函数</span></span><br><span class="line">	s3A = std::<span class="built_in">move</span>(s2A);			<span class="comment">// 移动赋值运算符</span></span><br><span class="line">	cout &lt;&lt; s3A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p> </p>
<h2 id="析构函数">析构函数</h2>
<p>  构造函数可以分配一个缓冲区或打开一个文件，在构造函数中分配资源后，就需要一个对应的操作来自动回收或释放资源。析构函数就是这样的特殊函数，作为构造函数的补充来完成所需的资源回收。当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数。</p>
<p>  不管类是否定义了自己的析构函数，编译器都将自动执行类中的非static数据成员的析构函数。</p>
<p>  构造函数不能被定义为虚函数，但析构函数可以被定义为虚函数。一般来说，如果类中定义了虚函数，那么析构函数也应被定义为虚析构，尤其是类内有申请的动态内存需要被清理和释放。</p>
<p>  假设类B是从类A继承的，如果类A的析构不是虚函数，那么如果基类指针pA指向new出来的B对象时，delete基类指针，只会运行基类的析构函数，而不会运行派生类的析构函数，造成资源释放不彻底。</p>
<p>  无论程序员是否定义了自己的析构函数，都会创建和运行合成析构函数。如果程序员自己定义了析构，那么再执行完自定义析构后会运行合成析构函数。合成析构函数按照对象创建时的逆序撤销每个非static成员，即声明次序的逆序。对于类类型的数据成员，合成析构函数调用该数据成员的析构函数来撤销对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() { cout &lt;&lt; <span class="string">"A"</span>; }</span><br><span class="line">	~<span class="built_in">A</span>() { cout &lt;&lt; <span class="string">"~A"</span>; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(A &amp;a):_a(a)  <span class="comment">//_a(a)调用了拷贝构造</span></span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"B"</span>;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	A _a;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	A _a; <span class="comment">//对象定义时自动调用构造，产生输出A</span></span><br><span class="line">	<span class="function">B <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">//输出B之前还调用了A的拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} <span class="comment">//对象声明周期结束后，按照构造函数的逆序依次调用析构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果“AB~B~A~A”</span></span><br><span class="line"><span class="comment">//先构造A，再构造B，符合对象先构造被包含的对象，再构造主对象</span></span><br><span class="line"><span class="comment">//析构的顺序是构造的逆序，复合对象先析构主对象，再析构包含的对象</span></span><br><span class="line"><span class="comment">//这里之所以走了两边A的析构，是因为这直接有一步拷贝构造，由于没有自定义所以没输出</span></span><br></pre></td></tr></table></figure>
<p> </p>
<h2 id="构造和析构的调用顺序">构造和析构的调用顺序</h2>
<h3 id="单继承">单继承</h3>
<p>  派生时构造和析构不能被继承，为了对基类成员初始化必须对派生类重新定义构造和析构，并在构造函数的初始化列表中调用基类的构造函数。派生类创建对象时，系统首先通过派生类的构造函数来调用基类的构造函数，完成基类成员的初始化，然后对派生类中新增的成员进行初始化。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名<span class="comment">(总参数表)</span> ： 基类构造函数<span class="comment">(参数表)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">}/</span><br></pre></td></tr></table></figure>
<p>  必须将基类的构造函数放在派生类的初始化列表中以调用基类构造函数，派生类构造函数调用顺序为：</p>
<ol type="1">
<li>完成对象所占整块内存的开辟，由系统在调用构造函数时自动完成；</li>
<li>调用基类的构造函数完成基类成员的初始化；</li>
<li>若派生类中含对象成员、const成员或引用成员，则必须在初始化列表中完成对其初始化；</li>
<li>派生类构造函数体执行；</li>
</ol>
<p> </p>
<p>  当对象被删除时，派生类的析构函数被执行</p>
<p> </p>
<h1 id="抽象法则">抽象法则</h1>
<p>  面向对象的误区：对象是对现实世界中具体物体的反映，继承是对物体分类的反映？这个观念是错误的。举个例子，现实生活中我们往往把正方形看作是长和宽都相等的特殊的长方形，如果把这个思想引入到C++中，可能会这么设计继承关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span>  <span class="comment">//长方形</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLength</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ……</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">square</span> : <span class="keyword">public</span> rectangle  <span class="comment">//正方形，继承长方形类</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLength</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ……</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  上面设计了两个类，一个长方形类，一个正方形类，其中正方形类继承了长方形类以及内部的方法SetLength。当我们调用长方形类SetLength的方法时，我们只是修改了长方形的长，长方形的宽不受影响；但是如果我们调用了正方形对象的SetLength方法，不仅长会受到影响，宽也会受到影响。这个从面向对象的继承体系来说就有很大的问题了。所以我们不要把现实世界中的关系代入到面向对象编程中。</p>
<h2 id="具体类型的抽象">具体类型的抽象</h2>
<ul>
<li><strong>让自定义的类像内置类型一样</strong></li>
</ul>
<p>  一个普通的int型变量，可以完成加、减、乘、除、比较、输出、自增等等一系列操作；如果现在有一个自定义的复数类型，我们自然也希望可以像使用int型变量一样使用它，同时它对我们是一个黑盒，一种抽象，我们不需要关心内部是如何实现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//complex.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>();                                    <span class="comment">// 默认构造函数</span></span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">double</span> r,  <span class="type">double</span> i);      <span class="comment">// 构造函数</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Complex</span>();                      <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; x);      <span class="comment">// 拷贝构造</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex &amp;c); <span class="comment">// =号运算符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetReal</span><span class="params">( )</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> _real; } <span class="comment">//const修饰函数，函数体内成员变量不允许改变</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetReal</span><span class="params">(<span class="type">double</span> d)</span> </span>{ _real = d; }</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">GetImage</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> _image; }<span class="comment">//const修饰函数，函数体内成员变量不允许改变</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetImage</span><span class="params">(<span class="type">double</span> i)</span> </span>{ _image = i; }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运算符重载</span></span><br><span class="line">    <span class="comment">//这里函数参数传递的是引用，因为可能从外面传递另外一个complex，但我们不想生成一个副本</span></span><br><span class="line">    <span class="comment">//重载等号操作符时返回的是引用，可以让返回值在其他地方使用</span></span><br><span class="line">	Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>; </span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> Complex &amp;c);</span><br><span class="line">	Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>-=(<span class="type">const</span> Complex &amp;c);</span><br><span class="line">	Complex <span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>*=(<span class="type">const</span> Complex &amp;c);</span><br><span class="line">	Complex <span class="keyword">operator</span>/(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>/=(<span class="type">const</span> Complex &amp;c);</span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Complex &amp;c); </span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex &amp;c)  <span class="type">const</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex &amp;c) <span class="type">const</span>;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前置和后置++</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>++();   <span class="comment">//前置++</span></span><br><span class="line">	Complex <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">//后置++</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>--();   <span class="comment">//前置--</span></span><br><span class="line">	Complex <span class="keyword">operator</span>--(<span class="type">int</span>); <span class="comment">//后置--</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//标准输入输出IO重载</span></span><br><span class="line">    <span class="comment">//输入输出需要把当前的Complex对象传递进来，也要把外部的ostream或istream传递进来</span></span><br><span class="line">    <span class="comment">//但是传递进来的ostream本身不是当前类内的成员变量，不能访问当前类的属性</span></span><br><span class="line">    <span class="comment">//所以定义为friend</span></span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Complex &amp;x);</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, Complex &amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _real;             <span class="comment">// 复数的实部</span></span><br><span class="line">	<span class="type">double</span> _image;         <span class="comment">// 复数的虚部</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//complex.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"complex.h"</span></span></span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>()</span><br><span class="line">{</span><br><span class="line">	_real = <span class="number">0.0</span>;</span><br><span class="line">	_image = <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "Complex::Complex()" &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i)</span><br><span class="line">{</span><br><span class="line">	_real = r;</span><br><span class="line">	_image = i;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "Complex::Complex(double r, double i)" &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex::<span class="built_in">Complex</span>(<span class="type">const</span> Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">	_real = c._real;</span><br><span class="line">	_image = c._image;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "Complex::Complex(const Complex&amp; c)" &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>= (<span class="type">const</span> Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;c)  <span class="comment">//如果二者相等，就不需要做操作，这里比较的是地址</span></span><br><span class="line">	{</span><br><span class="line">		_real = c._real;</span><br><span class="line">		_image = c._image;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex::~<span class="built_in">Complex</span>()</span><br><span class="line">{</span><br><span class="line">	_real = _image = <span class="number">0.0</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; "Complex::~Complex()" &lt;&lt; endl;</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+ (<span class="type">const</span> Complex&amp; c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//Complex tmp;</span></span><br><span class="line">	<span class="comment">//tmp._real = _real + c._real;</span></span><br><span class="line">	<span class="comment">//tmp._image = _image + c._image;</span></span><br><span class="line">	<span class="comment">//return tmp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的写法，在return的时候会触发拷贝构造</span></span><br><span class="line">    <span class="comment">//调试打断点可以发现，return会进入“=”操作符的重载，重载函数入参的地址和tmp这个临时对象的地址不一样</span></span><br><span class="line">    <span class="comment">//这个tmp被传递到拷贝构造里了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(_real + c._real, _image + c._image);</span><br><span class="line">    <span class="comment">//临时对象优化，上面的写法就不会触发拷贝构造，直接走了自定义的构造函数</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>+= (<span class="type">const</span> Complex&amp; c)</span><br><span class="line">{</span><br><span class="line">	_real += c._real;</span><br><span class="line">	_image += c._image;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(_real - c._real, _image - c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>-=(<span class="type">const</span> Complex &amp;c)</span><br><span class="line">{</span><br><span class="line">	_real -= c._real;</span><br><span class="line">	_image -= c._image;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>*(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(_real*c._real - _image*c._image, _real*c._image + _image*c._real);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>*=(<span class="type">const</span> Complex &amp;c)</span><br><span class="line">{</span><br><span class="line">	Complex <span class="built_in">tmp</span>(*<span class="keyword">this</span>);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">	_real = tmp._real*c._real - _image*c._image;</span><br><span class="line">	_image = tmp._real*c._image + tmp._image*c._real;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>/(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> t = c._real*c._real + c._image*c._image;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>((_real*c._real - _image*(-c._image)) / t, (_real*(-c._image) + _image*c._real) / t);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>/=(<span class="type">const</span> Complex &amp;c)</span><br><span class="line">{</span><br><span class="line">	Complex <span class="built_in">tmp</span>(*<span class="keyword">this</span>);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="type">double</span> t = c._real*c._real + c._image*c._image;</span><br><span class="line">	_real = (tmp._real*c._real - tmp._image*(-c._image)) / t;</span><br><span class="line">	_image = (tmp._real*(-c._image) + tmp._image*c._real) / t;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">return</span> (_real == c._real) &amp;&amp; (_image == c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> !( (_real == c._real) &amp;&amp; (_image == c._image) );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>&gt;(<span class="type">const</span> Complex &amp;c)  <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (_real &gt; c._real) &amp;&amp; (_image &gt; c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">return</span> (_real &gt;= c._real) &amp;&amp; (_image &gt;= c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> (_real &lt; c._real) &amp;&amp; (_image &lt; c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Complex::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> Complex &amp;c) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">return</span> (_real &lt;= c._real) &amp;&amp; (_image &lt;= c._image);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>++ () <span class="comment">// 前置++</span></span><br><span class="line">{</span><br><span class="line">	_real++;</span><br><span class="line">	_image++;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>++ (<span class="type">int</span>) <span class="comment">// 后置++</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//先用中间变量，然后执行计算，之后把原始值传递出去</span></span><br><span class="line">	<span class="comment">//Complex tmp(*this);</span></span><br><span class="line">	<span class="comment">//_real++;</span></span><br><span class="line">	<span class="comment">//_image++;</span></span><br><span class="line">	<span class="comment">//return tmp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的方法会调用拷贝构造，使用下面方法优化</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(_real++, _image++);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex&amp; Complex::<span class="keyword">operator</span>--()   <span class="comment">//前置--</span></span><br><span class="line">{</span><br><span class="line">	_real--;</span><br><span class="line">	_image--;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Complex Complex::<span class="keyword">operator</span>--(<span class="type">int</span>) <span class="comment">//后置--</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Complex</span>(_real--, _image--);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意输入输出的写法，虽然在类内声明了，但本身并不是类的成员</span></span><br><span class="line"><span class="comment">//所以定义为全局函数，不要加“Complex::”</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Complex &amp;x)</span><br><span class="line">{</span><br><span class="line">	os &lt;&lt; <span class="string">"real value is  "</span> &lt;&lt; x._real &lt;&lt; <span class="string">"  image value is "</span> &lt;&lt; x._image;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; is, Complex &amp;x)</span><br><span class="line">{</span><br><span class="line">	is &gt;&gt; x._real &gt;&gt; x._image;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">GetReal</span>() &lt;&lt; endl;     <span class="comment">// 1.0</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">GetImage</span>() &lt;&lt; endl;  <span class="comment">// 2.0 </span></span><br><span class="line">    a.<span class="built_in">SetImage</span>(<span class="number">2.0</span>);</span><br><span class="line">    a.<span class="built_in">SetReal</span>(<span class="number">3.0</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">GetReal</span>() &lt;&lt; endl;     <span class="comment">// 3.0</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">GetImage</span>() &lt;&lt; endl;  <span class="comment">// 2.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Complex <span class="title">a</span><span class="params">(<span class="number">3.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统也会默认有等号运算符的重载，我们自己不实现也可以用</span></span><br><span class="line">    Complex c;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意上面的写法和Complex c = a + b;的含义是不一样的</span></span><br><span class="line">    <span class="comment">//上面的行为是先声明后赋值</span></span><br><span class="line">    <span class="comment">//Complex c = a + b的行为是定义</span></span><br><span class="line">    <span class="comment">//调试时需要区别，如果要调试赋值操作，不要写成定义流程了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实际工程中尽量写Complex c = a + b;这个，减少一个默认构造函数提高效率</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Complex d;</span><br><span class="line">    d = c++;</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; d;</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  类中有个this指针，指向当前对象本身。</p>
<p>  类创建后会系统默认创建一个构造函数，我们可以自己实现构造函数。但我们如果重写了构造函数，那么原始的默认构造函数就不存在了，如果想使用需要重新声明实现。</p>
<p>  等号运算符也一样，系统会默认帮我们重载。不过我们最好不要过于相信系统默认的重载，在复杂情况下运算的结果可能不是我们想要的。</p>
<p>  程序中的临时对象一定要注意优化，避免产生临时对象，否则会触发拷贝构造。</p>
<p>  </p>
<h2 id="抽象类型的抽象">抽象类型的抽象</h2>
<p>  数学中有不同的图形，比如长方形、原型、三角形；多种图形计算周长、面积的方法不同，但都需要一个计算方法。我们可以抽象出一个图形类Shape，用Shape类进行公共层面的抽象操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="comment">// 抽象类的特征是虚函数后面都是"=0",意味着不可以有实际的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">// 子类方法实现不一致时要加上virtual</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetColor</span><span class="params">(<span class="type">int</span> color)</span> </span>{ _color = color; }</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span>   <span class="comment">//一个共性的方法</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		cout &lt;&lt; <span class="built_in">Area</span>() &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> _color;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>: <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Square</span>(<span class="type">double</span> len) :_len(len) { } <span class="comment">//用参数列表初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"Square"</span> &lt;&lt; endl; }</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> _len*_len;</span><br><span class="line">	}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _len; <span class="comment">//边长</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Circle</span>(<span class="type">double</span> radius) :_radius(radius) {} <span class="comment">//用参数列表初始化</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"Circle"</span> &lt;&lt; endl; }</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3.1415926</span>*_radius*_radius;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _radius;  <span class="comment">//半径</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Triangle</span>(<span class="type">double</span> len, <span class="type">double</span> height) :_len(len), _height(height){}</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"Triangle"</span> &lt;&lt; endl; }</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.5</span>*_len*_height;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> _len;  <span class="comment">//底</span></span><br><span class="line">	<span class="type">double</span> _height;     <span class="comment">//高</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">// 多态的实现，可以让我们面对变化，尽可能少修改原有的逻辑，直接扩充逻辑</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> shapeNum = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Square <span class="title">s1</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line">	s1.<span class="built_in">SetColor</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="function">Circle   <span class="title">c1</span><span class="params">(<span class="number">2.0</span>)</span></span>;</span><br><span class="line">	<span class="function">Triangle <span class="title">t1</span><span class="params">(<span class="number">2.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	Shape* shapes[shapeNum];</span><br><span class="line">	shapes[<span class="number">0</span>] = &amp;s1;</span><br><span class="line">	shapes[<span class="number">1</span>] = &amp;c1;</span><br><span class="line">	shapes[<span class="number">2</span>] = &amp;t1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> index = <span class="number">0</span>; index &lt; shapeNum; index++)</span><br><span class="line">	{</span><br><span class="line">		shapes[index]-&gt;<span class="built_in">Display</span>();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(s1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> </p>
<h1 id="对象模型和虚函数">对象模型和虚函数</h1>
<p>  C++的对象模型中，子类对象中包含了父类。父类中有一个虚函数列表，是个类似数组的结构。对象模型中只保留成员变量信息和虚函数列表，其他的共有函数是通过this指针来访问的。</p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/%E8%99%9A%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.png"></p>
<h1 id="面向对象三大特性">面向对象三大特性</h1>
<ul>
<li>封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问；封装可以使得代码模块化；</li>
<li>继承性：让某种类型对象获得另一个类型对象的属性和方法，继承可以扩展已经存在的代码；</li>
<li>多态性：同一事物在保有原来特点的情况下表现出不同事物的能力，即不同对象会产生不同的行为；多态的目的是为了接口重用；</li>
</ul>
<p>  面向对象是软件工程发展到一定阶段为了管理代码和数据提出的一种方法，它没有解决以前解决不了的问题，不是万能的，只是为我们便捷的开发出能适应快速变化的软件提供了可能。面向对象不是对现实世界的映射，但它的封装性可以把问题简化；它的继承性可以减少代码重复，避免重新发明轮子；它的多态可以实现灵活的功能扩充，提升开发效率；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" class="post-title-link" itemprop="url">字符编码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-05-09 16:43:40" itemprop="dateCreated datePublished" datetime="2025-05-09T16:43:40+08:00">2025-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-29 14:05:53" itemprop="dateModified" datetime="2025-05-29T14:05:53+08:00">2025-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ascii码表">ASCII码表</h1>
<p>  ASCII(American Standard Code for Information
Interchange,美国信息交换标准代码)是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC
646。</p>
<p>  
ASCII码使用指定的7位或8位二进制数组合来表示128或256种可能的字符。美国一开始设计的是7位共128个，包含95个可见字符和33个控制字符，后期扩展到8位，称为扩展ASCII码。</p>
<p>  </p>
<h1 id="国标编码">国标编码</h1>
<p>  中国也有自己的编码，用于表示中文字符。设计编码首先要确定字符集。国标使用分区管理，共计分为94个区，每个区含94位，共8836个码位。1<sub>9区收录除汉字外的682个字符；10</sub>15区为空白区，没有使用；16<sub>55区收录3755个一级汉字，按照拼音排序；56</sub>87区收录3008个二级汉字，按照部首/笔画排序；剩余的88~94区为空白区，没有使用。这套字符集称为<strong>GB2312</strong>字符集。按照这个字符集来编码，比如3区的6行7列字符，编码0367。</p>
<p>  ASCII是直接把码位按照二进制存储，但国标编码不是。比如5709编码的汉字(侃)，把6709按照前两位和后两位分开，并分别转为16进制：0x39和0x09；然后两个数分别加上0xA0得到0xD9和0xA9，将两数合并，0xD90xA9就是汉字侃的GB2312码。</p>
<p>  GB2312编码之所以要加0xA0，是为了要兼容ASCII码。GB2312是双字节编码，为了与ASCII编码区分，每个单字节的第八位必须是1，所以GB2312编码最少要从0x80(1000
0000)开始。但是根据规定，0x80~0x9F需要留给控制块，所以只能从0xA0开始。</p>
<p>  计算机判断字符是ASCII码还是GB2312编码的方式就是通过字符大小，ASCII码是7个字节，如果小于127就是ASCII码，如果连续碰到两个大于127的8位就把两个组合起来当作GB2312编码。</p>
<p>  GB2312编码只能表示6763个汉字，后期也不够用了，所以对GB2312做了扩展为<strong>GBK字符集</strong>。GB2312的高位和地位都要求必须大于127，GBK不再规定低位大于127，只保证高位大于127。把之前没用上的码位都用上，扩充了将近20000个汉字和符号。计算机只要碰到一个大于127的字节，就表示一个汉字的开始。</p>
<p>  后期还扩展了GB18030字符集，新增了少数民族的字符。</p>
<p>  </p>
<h1 id="unicode">Unicode</h1>
<p>  ASCII可表示的字符数太少了，但如果每个国家都设计一套自己的编码就太乱了，为了把世界上的文字都映射到一套字符空间中，诞生了Unicode。Unicode是一个标准，规定了字符集和编码。</p>
<p>  最开始的Unicode字符集称为UCS-2字符集，和ASCII码一样，把用到的字符按顺序罗列并标上对应的码位。存储方式和ASCII一样，直接把码位按照二进制方式存储。一共可以表示<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container></span>即65536个字符。后期发现不够用后出现了UCS-4字符集，可以表示<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container></span>将近43亿个字符，但由于这个编码占用的存储空间太大了，并没有被广泛接受。</p>
<p>  互连网时代后，对Unicode做了优化，目前有3种Unicode的编码方式：</p>
<ol type="1">
<li>UTF-8：用1byte来表示字符，可以兼容ASCII码；
<ol type="1">
<li>特点是存储效率高，可变长（不方便内部随机访问）;</li>
<li>无字节序问题，可以作为外部编码；</li>
</ol></li>
<li>UTF-16：用2bytes表示一个字符，可以分为UTF-16BE(big
endian)和UTF-16LE(little endian)
<ol type="1">
<li>特点是定长的，方便内部随机访问；</li>
<li>有字节序问题，不可以作为外部编码；</li>
</ol></li>
<li>UTF-32：用4bytes表示一个字符，可以分为UTF-32BE(big
endian)和UTF-32LE(little endian)
<ol type="1">
<li>特点是定长的，方便内部随机访问；</li>
<li>有字节序问题，不可以作为外部编码；</li>
</ol></li>
</ol>
<p>   注意：如果使用的Windows系统，Windows文件可能有BOM(byte order
mark)来表示字节序，如果要在其他平台使用，可以去掉BOM或者忽略掉。BOM在文本文件头部，FEFF(十进制为254
255)表示大端，FFFE(十进制为255 254)表示小端。</p>
<p>  </p>
<p>  UTF-8编码原理：UTF-8将UCS-4字符集的码位划分为4个区间(0x00000000<sub>0x0000007F；0x00000080</sub>0x000007FF；0x00000800<sub>0x0000FFFF；0x00010000</sub>0x0010FFFF)，第一个区间的编码样式为0XXXXXXX，第二个区间的编码样式为110XXXXX
10XXXXXX，第三个区间的编码样式为1110XXXX 10XXXXXX
10XXXXXX，第四个区间的编码样式为11110XXX 10XXXXXX 10XXXXXX
10XXXXXX。</p>
<p>  汉字“王”在UCS-4中的编码为0x0000738B，转换为二进制就是“0000 0000
0000 0000 0111 0011 1000
1011”。0x0000738B属于UCS-4的第三区间，这个区间的编码样式是“1110XXXX
10XXXXXX
10XXXXXX”。此时我们得到了“王”这个字符的二进制形式和编码样式，把二进制形式从高到低依次插入到编码样式中，得到了“王”对应的UTF-8编码：“11100111
10001110 10001011”，十六进制为“0xe7 0x8e 0x8b”。</p>
<p>  </p>
<p><strong><u>程序中编码错误的根本原因在于编码方式和解码方式的不统一。</u></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liu-fb.com/2025/C/C++/C%E5%88%B0C++%E7%9A%84%E6%94%B9%E8%BF%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="Fabian">
      <meta itemprop="description" content="水止无恒地，云行不计程。到时为彼岸，过处即前生。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fabian备忘录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/C/C++/C%E5%88%B0C++%E7%9A%84%E6%94%B9%E8%BF%9B/" class="post-title-link" itemprop="url">C到C++的改进</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-02 15:51:49" itemprop="dateCreated datePublished" datetime="2025-04-02T15:51:49+08:00">2025-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-18 16:59:56" itemprop="dateModified" datetime="2025-04-18T16:59:56+08:00">2025-04-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.7k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="c语言字符的语法陷阱">C语言字符的语法陷阱</h1>
<p>先看C语言中常见的词法、语法问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c1 = <span class="string">'yes'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 不符合常理，但这样定义没有错误</span></span><br><span class="line"><span class="comment">* 编译器会截断</span></span><br><span class="line"><span class="comment">* 至于是保留第一个还是最后一个，这个和编译器有关</span></span><br><span class="line"><span class="comment">* 虽然没报错，但编译器会有warning</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">"yes"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 编译器报错</span></span><br><span class="line"><span class="comment">* "yes"是一个字符串，c2只是一个字符变量，不能存储字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* slash = <span class="string">"/"</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符串的正确定义方法</span></span><br><span class="line"><span class="comment">slash中存放两个字符：'/'、'\0'</span></span><br><span class="line"><span class="comment">这样其实就是把字符串的首地址给了指针变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* slash2 = <span class="string">'/'</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器报错</span></span><br><span class="line"><span class="comment">字符的类型不能给指针，两个变量类型不匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* slash3 = &amp;c1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">正确</span></span><br><span class="line"><span class="comment">slash3指针变量存放c1单个字符的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>  从上面的例子可以看到，C语言是高级语言中的低级语言，优点是小巧、高效、接近底层，比如上面的例子就把字符和字符串区分的很细，但缺点就是细节和陷阱比较多。为了更好的解决这个问题，C++在兼容C语言的同时，推出了既高效又易于大规模开发的机制：string类的使用:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="number">1</span>,<span class="string">'yes'</span>)</span></span>;  <span class="comment">//s</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="number">3</span>,<span class="string">'yes'</span>)</span></span>;  <span class="comment">//sss</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="number">1</span>,<span class="string">'y'</span>)</span></span>;    <span class="comment">//y</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">"/"</span>)</span></span>;      <span class="comment">// /</span></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="number">1</span>,<span class="string">'/'</span>)</span></span>;    <span class="comment">// /</span></span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="string">"yes"</span>)</span></span>;    <span class="comment">//yes</span></span><br></pre></td></tr></table></figure>
<h1 id="c语言指针和数组的关系问题">C语言指针和数组的关系问题</h1>
<p>c预言数组在作为参数时的退化行为，退化为一个指针。</p>
<p>给定一个数组，计算数组中的数据的平均数，有以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算平均数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average1</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"In average1 : "</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		result += arr[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result / len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> array1[] = { <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">100</span> };</span><br><span class="line"></span><br><span class="line">	<span class="comment">//数组长度最好是用变量这样来求，不要写成常量</span></span><br><span class="line">	<span class="comment">//这样方便扩展</span></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(array1) / <span class="built_in">sizeof</span>(array1[<span class="number">0</span>]);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">"len : "</span> &lt;&lt; len &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">average1</span>(array1) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B11.png"></p>
<p>  可以看到输出的值并不是平均数，通过输出中间数据可以知道，main函数中的长度是10，而average1中的数组长度是1；</p>
<p>  出现这个的原因就是C预言数组在作为函数参数传递时会退化为一个指针，average1中的入参实际上只是函数的首地址，sizeof(arr)输出的只是单个元素的长度。</p>
<p>  可以进行如下优化，通过外部把数组长度先行计算出来然后传递给函数。需要注意，如果传递的是字符数组的话就不需要这么麻烦了，因为字符数组往往是通过'\0'结尾的，函数内部有办法知道数组的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接把数组长度传递进来</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average2</span><span class="params">(<span class="type">int</span> arr[<span class="number">10</span>], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		result += arr[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result / len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> array1[] = { <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">100</span> };</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> len = <span class="built_in">sizeof</span>(array1) / <span class="built_in">sizeof</span>(array1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">average2</span>(array1,len) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  其实知道数组当作函数参数传递时会发生退化时，就可以不传递数组，而是只传递指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">average2</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	{</span><br><span class="line">		result += arr[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result / len;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  C语言之所以要这么做，是和c语言发展分不开的。c语言早期是伴随着unix操作系统，是非常底层的，对空间要求非常高的语言。如果函数传参时传递了一个非常大的数据容器，空间转移的效率是非常低的。所以C语言设计者就通过传递指针和容器尺寸这样一种传递方式从而达到节省空间的目的。</p>
<p>  </p>
<p>  C++的解决方案就是引入STL容器，实现底层包装，保证效率的同时也保证简单安全。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里传递的是引用</span></span><br><span class="line"><span class="comment">//如果传递的是vector本身，c++这里会产生一个副本，如果容器很大会得不偿失</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">average3</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (;it!=v.<span class="built_in">end</span>();++it)</span><br><span class="line">	{</span><br><span class="line">		result += *it;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result / v.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vt = { <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">100</span> };</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">average3</span>(vt) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  使用stl容器后，哪怕是二维数组，处理起来也很方便了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">average2DV</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; vv)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; vv.<span class="built_in">size</span>(); ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; vv[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">		{</span><br><span class="line">			result += vv[i][j];</span><br><span class="line">			size += <span class="number">1</span>;</span><br><span class="line">			cout &lt;&lt; vv[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		}</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result / size;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; vv2D{<span class="number">8</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">12</span>,<span class="number">3</span>) }; <span class="comment">//8个vector，每个包含12个3</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">average2DV</span>(vv2D);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="c语言的移位问题">C语言的移位问题</h1>
<p>问题一：右移操作：无法区分是逻辑右移还是算术右移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> a1 = <span class="number">0x63</span>;       <span class="comment">// 0110 0011</span></span><br><span class="line">	a1 = (a1 &lt;&lt; <span class="number">4</span>);        <span class="comment">// 0011 0000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a1);  <span class="comment">//左移操作，末位补0</span></span><br><span class="line"></span><br><span class="line">	a1 = <span class="number">0x63</span>;                <span class="comment">// 0110 0011</span></span><br><span class="line">	a1 = (a1 &gt;&gt; <span class="number">4</span>);        <span class="comment">//  0000 0110 逻辑右移</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a1);  <span class="comment">// 逻辑右移自动补0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> a2 = <span class="number">0x95</span>;       <span class="comment">// 1001 0101</span></span><br><span class="line">	a2 = (a2 &lt;&lt; <span class="number">4</span>);        <span class="comment">// 0101 0000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a2);  <span class="comment">//左移操作，末位补0</span></span><br><span class="line"></span><br><span class="line">	a2 = <span class="number">0x95</span>;                <span class="comment">// 1001 0101</span></span><br><span class="line">	a2 = (a2 &gt;&gt; <span class="number">4</span>);        <span class="comment">//  1111 1001 算术右移</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a2);   <span class="comment">//这里执行的是算数右移操作，补1了</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  上面可以看到，C语言在执行右移操作时表现不同，而不同的编译器输出的结果可能都不一样，C语言并没有做统一标准。C语言官方的做法是在做右移操作时，把操作数都变为无符号的数，这样可以保证执行的是逻辑右移操作（补0）。原因是无符号数首位都是0，可以保证补位的数也是0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> a3 = <span class="number">0x63</span>;       <span class="comment">// 0110 0011</span></span><br><span class="line">	a3 = (a3 &lt;&lt; <span class="number">4</span>);        <span class="comment">// 0011 0000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a3);</span><br><span class="line"></span><br><span class="line">	a3 = <span class="number">0x63</span>;                <span class="comment">// 0110 0011</span></span><br><span class="line">	a3 = (a3 &gt;&gt; <span class="number">4</span>);        <span class="comment">//  0000 0110 逻辑右移</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> a4 = <span class="number">0x95</span>;       <span class="comment">// 1001 0101</span></span><br><span class="line">	a4 = (a4 &lt;&lt; <span class="number">4</span>);        <span class="comment">// 0101 0000</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a4);</span><br><span class="line"></span><br><span class="line">	a4 = <span class="number">0x95</span>;                <span class="comment">// 1001 0101</span></span><br><span class="line">	a4 = (a4 &gt;&gt; <span class="number">4</span>);        <span class="comment">//  0000 1001 逻辑右移</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, a4);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  </p>
<p>问题二：移位操作位数的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//示例常见与权限控制，每一位代表不同的权限</span></span><br><span class="line">	<span class="comment">//0000 0000</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> priv = <span class="number">0xFF</span>;  <span class="comment">//初始化权限</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> P_BAKCUP = (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);  <span class="comment">//备份权限</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> P_ADMIN = (<span class="number">1</span>&lt;&lt;<span class="number">8</span>);   <span class="comment">//最高权限</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, P_BAKCUP);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, P_ADMIN);</span><br><span class="line">	<span class="keyword">if</span> (priv &amp; P_BAKCUP)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"BAKUP"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (priv &amp; P_ADMIN)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"ADMIN"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B12.png"></p>
<p>  由运行结果可以看到，char本身就只有8位，P_ADMIN的移位操作已经超过了8位，这时候所有的8位都被清零了。这是C语言编码常见错误，移位操作一定要注意操作位数上限，移位数大于0，小于位数；</p>
<p>  </p>
<p>  出现上面两个问题的原因就是，C语言设计移位操作时需要考虑操作数表示的上下文环境。C++为了对这个问题做改进，引入了bitset：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// bitset</span></span><br><span class="line">	bitset&lt;10&gt; priv = <span class="number">0xFF</span>;  <span class="comment">//手动控制，这里就只有10位</span></span><br><span class="line">	bitset&lt;10&gt; P_BAKCUP = (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br><span class="line">	bitset&lt;10&gt; P_ADMIN = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里可以直接输出</span></span><br><span class="line">	cout &lt;&lt; priv &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; P_BAKCUP &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; P_ADMIN &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((priv &amp; P_BAKCUP) == P_BAKCUP)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"BAKUP"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((priv &amp; P_ADMIN) == P_ADMIN)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; <span class="string">"ADMIN"</span> &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B13.png"></p>
<h1 id="c语言强制类型转换问题">C语言强制类型转换问题</h1>
<p>C语言中强制类型转换隐藏了很多bug和陷阱：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using  namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> };</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="type">int</span> threshold = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) &gt; threshold)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"positive number array"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"negative number array"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B14.png"></p>
<p>  上面的代码当数组长度大于0时，需要输出“positive number
array”，否则输出“negative number
array”。可以通过编译运行后，长度输出为3是正确的，但判断逻辑里却输出了“negative
number array”。</p>
<p>  发生这个问题的原因是sizeof的返回值是unsigned
int,是无符号数，但threshold却是一个有符号数，在执行比较判断语句时，C语言的机制把threshold转换为了一个无符号数，然后才进行的比较。这里发生的是<strong>隐式类型转换</strong>。-1转换为unsigned
int时会变为4294967295，是个很大的正整数（这里涉及到了补码转换）。</p>
<p>  C语言在编写时，可以先用一个有符号的数把数据先取出来。今后编码时也需要注意，尽量避免用无符号的数据来进行数据比较：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using  namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> <span class="built_in">array</span>[] = { <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> };</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="type">int</span> threshold = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);  <span class="comment">//用一个有符号的变量先把数据拿出来</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (len &gt; threshold)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"positive number array"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"negative number array"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  </p>
<p>类型转换还可能会发生在以下情况：假设要计算1+1/2+1/3+……+1/n，如果代码是这么写的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1+1/2+1/3+1/4+... +1/n</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		result += <span class="number">1</span> / i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getSum(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B15.png"></p>
<p>可以看到，计算出的结果是1。这里的问题出在“result +=
1/n”这句中，被除数是整形，除数也是整形，那么计算结果也是整型值。result虽然会转换为浮点数，但整形计算中已经丢失了精度。</p>
<p>c语言中的一个解决方法是把被除数先转换为浮点数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1+1/2+1/3+1/4+... +1/n</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		result += <span class="number">1.0</span> / i;  <span class="comment">//把被除数换成浮点数，那么结果会被转换为浮点数</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; getSum(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>  </p>
<p>  </p>
<p>  上面两个例子可以看到，有时候我们会忽略C语言的隐式类型转换，导致出现程序bug；但有时候我们又需要这种隐式类型转换来得到我们想要的结果。c语言中滥用类型转换可能导致灾难性的后果，且很难排查。C语言之所以这么设计，是因为类型转换在底层语言中的运用非常广泛，且灵活方便。C++为了方便排查隐藏bug减少复杂性，提供了四种类型转换的方式：<strong>static_cast、const_cast、dynamic_cast、reinterpret_cast</strong>。</p>
<ul>
<li>static_cast：其实就是类似于C语言中的类型转换，C++提供了这么一种标准格式用于显示类型转换，可以方便程序员精准定位程序哪里使用了强制类型转换；</li>
<li>const_cast：只针对去除const属性；</li>
<li>dynamic_cast：用于类的继承关系转换，比如把子类转换为父类、或者父类转换为子类；</li>
<li>reinterpret_cast：用于指针的转换；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1+1/2+1/3+1/4+... +1/n</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		result += <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>) / i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">getSum</span>(n) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="c语言的整数溢出问题">C语言的整数溢出问题</h1>
<p>  32位系统中，一个整数占用4个字节，共32位。其中第一位是符号位，所以一共有31位可以表示整数范围。如果计算的时候，如果我们算出的数值超出了数据表示范围，那么会数据溢出变为负数。要注意C语言中的整数不能和数学上的整数划等号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">2147483640</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &gt; <span class="number">0</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"adding "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"exit "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B16.png"></p>
<p>  出现这个问题的原因和系统的设计是有关的。数据存储空间是有限的，不能无限增长。C语言的一个解决方案是通过字符串的方式来表达大数的运算，字符串理论上是可以无限长的，C语言是有这个类库的，但并没有直接的解决方案。
C++本身也没有提供好的解决方案，但boost库中提供了cpp_int方法：<a target="_blank" rel="noopener" href="https://www.boost.org/">boost官网</a></p>
<p>  </p>
<h1 id="c语言字符串的典型缺陷">C语言字符串的典型缺陷</h1>
<p>  C标准字符和字符串的区别是：字符是单引号括起来的，字符串是双引号括起来的，由'\0'结尾。而'\0'作为结束符这个方式，表达能力有天生的缺陷：一旦字符串中间具有'\0'字符，那么c语言的字符串函数就会认为这个字符已经结束了。如果用c语言的方式存储一些图片或者其他二进制的内容，很容易出问题。</p>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B17.png"></p>
<p>  C语言的字符串操作还有另一个问题就是效率低下。C语言的字符处理函数都是通过遍历'\0'来寻找字符串结尾的，这个遍历操作会消耗性能。</p>
<p>  C语言设计这种字符串处理方式主要是为了节省空间，有针对性的设计问题。C++语言为了解决这个问题有以下几种思路：</p>
<ul>
<li>C++的string类</li>
<li>开源库<a target="_blank" rel="noopener" href="https://github.com/redis">Redis</a>解决方案，<a target="_blank" rel="noopener" href="https://redis.io/">redis官网</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	cout &lt;&lt; <span class="string">"Testing C++ String: "</span> &lt;&lt; endl;</span><br><span class="line">	string sstr1 = <span class="string">"string"</span>;</span><br><span class="line">	cout &lt;&lt; sstr1.<span class="built_in">length</span>() &lt;&lt; endl;  <span class="comment">//字符串内容的长度</span></span><br><span class="line">	cout &lt;&lt; sstr1.<span class="built_in">capacity</span>() &lt;&lt; endl; <span class="comment">//string的容量长度</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(sstr1) &lt;&lt; endl;  <span class="comment">//实际内存分配长度，不同平台的值可能不一致，但实际大小肯定会大于内容长度</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"sstr2: "</span> &lt;&lt; endl;</span><br><span class="line">	string sstr2 = <span class="string">"stri\0ng"</span>;</span><br><span class="line">	cout &lt;&lt; sstr2.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sstr2.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(sstr2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">"sstr1: "</span> &lt;&lt; endl;</span><br><span class="line">	sstr1 += sstr2;   <span class="comment">//字符串直接拼接</span></span><br><span class="line">	cout &lt;&lt; sstr1.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; sstr1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(sstr1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><img src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/C%2B%2B/c%E9%99%B7%E9%98%B18.png"></p>
<p>  可以看到，string类的实现方案中，内部不仅记录了字符串的内容，还有几个变量记录了字符串内容的长度、容量等，在执行字符串操作时不需要遍历寻找'\0'，提高了效率；但是依旧保留了c风格字符串以'\0'结尾的传统，还具有一些缺陷。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fabian"
      src="https://my-hexo-blog-1308129409.cos.ap-beijing.myqcloud.com/Hexo%E5%8D%9A%E5%AE%A2/%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">Fabian</p>
  <div class="site-description" itemprop="description">水止无恒地，云行不计程。到时为彼岸，过处即前生。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Liuqianci" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Liuqianci" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/Damon_liufb@163.com" title="E-Mail → Damon_liufb@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="bed"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FabianLiu</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">147k</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div> -->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

  <script async src="/js/cursor/love.min.js"></script>


</body>
</html>
